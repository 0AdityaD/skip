# Experimental WebAssembly Support

This directory contains the scripts and runtime support for some basic experiments with using [WebAssembly](http://webassembly.org/) as a back end target for Skip.

The setup here uses Skip's native back end, which generates LLVM bitcode, and passes that through an existing version of clang capable of generating ouput code for the wasm32 (WebAssembly) architecture.  This output assembly code is then converted into the [WebAssembly S-expression format](https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format), and then converted into the compact WebAssembly byte-code binary format.

# Setup

### Generate 32-bit version of preamble:

In top level Skip `build` directory:

```console
$ ninja preamble32.tests.dep
```

This forces a build of a 32-bit version of `preamble.ll`, needed for compiling Skip's generated LLVM bitcode to WebAssembly.
The generated preamble file (in the build directory) is `./src/runtime/native/lib/preamble32.ll`.

### Update `third-party`

At the top level of your Skip repository:

```console
$ git submodule update --init --recursive
```

### Build `third-party/wabt`

From the top level of your Skip repository:

```console
$ cd third-party/wabt
$ make
```

### Install npm dependencies in `third-party/assemblyscript-runtime`

From the top level of your Skip repository:

```console
$ cd third-party/assemblyscript-runtime
$ npm install
```

### Install wasm32 clang to `third-party/assemblyscript-runtime`

**This step is necessary to work around a [known bug](https://github.com/dcodeIO/webassembly/issues/6) in the previous step.**

This step requires that you have the `wget` command installed.  If you do not have `wget`, do:
```
$ brew install wget
```

While you are still in the `third-party/assemblyscript-runtime` directory:

```console
$ ../../experimental/wasm/tools/clang-setup.sh
```

### Build `third-party/assemblyscript-runtime`

While you are still in the `third-party/assemblyscript-runtime` directory:

```console
$ npm run build
```

# Trying it out

From the top level of your Skip repository:

```console
$ cd experimental/wasm/examples
$ ../tools/skip_wasm_exec addTwo.sk
```
If all goes well, after about 15 sec. or so, you should see:
```console
$ ../tools/skip_wasm_exec addTwo.sk
Result is: 22.0

22.0
```

The scripts stored intermediate output files in the directory `./out`.  Here is a quick guide to the generated files:

* `out/sk.ll` -- LLVM bitcode generated by the Skip Native Back End.
* `out/sk.s` -- Assembler output for the wasm32 architecture produced by the clang binary compiled with wasm32 support (using `out/sk.ll` as input).
* `out/sk.wat` -- WebAssembly S-expression textual format; effectively just a reformatting of `out/sk.s`.
* `out/sk.wasm` -- Binary encoding of `out/wx.wat` in WebAssembly binary format, suitable for loading into Node or a Browser.

Once the application has been compiled to a `.wasm` file, a JavaScript wrapper `../runtime/runSkWasm.js` is run in node to load and run the WebAssembly file.  If you want to run this generated `sk.wasm` file without recompiling:

```console
$ node ../runtime/runSkWasm.js ./out/sk.wasm
Result is: 22.0

22.0
```

The couple of other example files (which run!) exercise a few more of the basic features of Skip.  It's illsutrative to examine the generated `.wat` file for `vecTest.sk` -- the Skip
inliner completely eliminates all object allocation.

# Other examples

## VectorTest -- writing a custom main in JavaScript

The files `example/vectorTest.sk` and `examples/vectorTest.js` demonstrate how to load WebAssembly compiled from Skip, load and call it from JavaScript and extract data from the Skip runtime heap for functions that return pointers.

In the `experimental/wasm/examples` directory:
```console
$ ../tools/skip_to_wasm -o vectorTest.wasm vectorTest.sk
$ node vectorTest.js
```

## Basic Browser Test

**Note**: The following two examples use the binary file `experimental/wasm/runtime/dist/runtime.wasm`.  This is just a checked-in copy of the binary file `/third-party/assemblyscript-runtime/dist/runtime.wasm`; only checked in to make it a bit easier to serve via a local HTTP server.

Build setup:

```console
$
$ cd experimental/wasm/examples/browser
$ ../../tools/skip_to_wasm -o addTwo.wasm addTwo.sk
$ cd ../.. # up to experimental/wasm
$ python -m SimpleHTTPServer
```

Then navigate to [http://localhost:8000/examples/browser/addTwo.html](http://localhost:8000/examples/browser/addTwo.html)
and open the Console.  You may need to reload the page to see the console output.

## Mandelbrot Set

This is a Skip port of the core calculation found [in this JavaScript Mandelbrot set tutorial] (http://progur.com/2017/02/create-mandelbrot-fractal-javascript.html).  The example uses the original JavaScript rendering code to paint pixels in the Canvas, but uses Skip compiled to WebAssembly to calculate the value for each pixel.

Build setup:

```console
$
$ cd experimental/wasm/examples/mandelbrot
$  ../../tools/skip_to_wasm -o mandelbrot.wasm *.sk
$ cd ../.. # up to experimental/wasm
$ python -m SimpleHTTPServer
```

Then navigate to [http://localhost:8000/examples/mandelbrot/mandelbrot.html](http://localhost:8000/examples/mandelbrot/mandelbrot.html)

# Going Further

More complex examples are unlikely to run out of the box for a couple of reasons:

1. There is an issue with the Native Back End's construction of vtables for 32-bit architectures that causes an issue for programs that use objects. This is being fixed.
2. Wasm needs JavaScript implementations for all runtime intrinsics.  Only a tiny subset of these routines are currently implemented, and many are simple placeholders -- see `setupBuiltins` in `../runtime/skWasmUtils.js` for details.
