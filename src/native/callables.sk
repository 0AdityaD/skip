/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// AUTOGENERATED FILE - DO NOT EDIT
// Generated with: python3 src/native/make_callables.py

module alias O = OuterIstToIR;

module HhvmInterop;

class CopyFromHhvm extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.copyFromHhvm";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    handle: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targT,
      targs => Array[targT],
      args => Array[handle],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = targT;
  }
}

class CopyOptionToHhvm() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.copyOptionToHhvm";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Option"),
        DeepFrozen(),
        Array[tHhvmHandle],
      ),
      targs => Array[targT],
      args => Array[obj],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Option"),
      Array[tHhvmHandle],
      DeepFrozen(),
    );
  }
}

class CopyToHhvm extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.copyToHhvm";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => tHhvmHandle,
      targs => Array[targT],
      args => Array[obj],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = tHhvmHandle;
  }
}

class CreateFromProxyPointer extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.createFromProxyPointer";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targT,
      targs => Array[targT],
      args => Array[value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = targT;
  }
}

class CreateFromProxyPointerAndType extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.createFromProxyPointerAndType";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    handle: O.MaybeExists<O.InstrTree>,
    hhvmType: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targT,
      targs => Array[targT],
      args => Array[handle, hhvmType],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = targT;
  }
}

class FetchProxyPointer extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.fetchProxyPointer";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    ptr: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => tHhvmHandle,
      targs => Array[targT],
      args => Array[ptr],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = tHhvmHandle;
  }
}

class HhvmVariantFactoryFromNullable() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.hhvmVariantFactoryFromNullable";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    variant: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT],
      args => Array[variant, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
  }
}

class InternalBitcastLambdaToRetValue() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalBitcastLambdaToRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    i: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      args => Array[i],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class InternalBitcastToRetValue extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalBitcastToRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    i: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      targs => Array[targT],
      args => Array[i],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class InternalCreateFrozenFromItems extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateFrozenFromItems";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    i: Type,
    items: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => t,
      targs => Array[t, i],
      args => Array[items],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass, i: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t, i]);
    _ = t;
  }
}

class InternalCreateFrozenFromIterator extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateFrozenFromIterator";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    i: Type,
    items: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => t,
      targs => Array[t, i],
      args => Array[items],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass, i: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t, i]);
    _ = t;
  }
}

class InternalCreateMutableFromItems extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateMutableFromItems";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    i: Type,
    items: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => t,
      targs => Array[t, i],
      args => Array[items],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass, i: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t, i]);
    _ = t;
  }
}

class InternalCreateMutableFromIterator extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateMutableFromIterator";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    i: Type,
    items: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => t,
      targs => Array[t, i],
      args => Array[items],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass, i: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t, i]);
    _ = t;
  }
}

class InternalCreateParamTupleFromNullableObject() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateParamTupleFromNullableObject";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    nullable: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targT,
      targs => Array[targT],
      args => Array[nullable],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = targT;
  }
}

class InternalCreateParamTupleFromNullableString() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateParamTupleFromNullableString";

  static fun call(
    fs: mutable O.FunSpecializer,
    nullable: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Unsafe.RawStorage"),
        DeepFrozen(),
        Array[tString],
      ),
      args => Array[nullable],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Unsafe.RawStorage"),
      Array[tString],
      DeepFrozen(),
    );
  }
}

class InternalCreateParamTupleFromNullableT() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateParamTupleFromNullableT";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    nullable: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, targT],
      ),
      targs => Array[targT],
      args => Array[nullable],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, targT],
      DeepFrozen(),
    );
  }
}

class InternalCreateParamTupleFromOption() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateParamTupleFromOption";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    nullable: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, targT],
      ),
      targs => Array[targT],
      args => Array[nullable],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, targT],
      DeepFrozen(),
    );
  }
}

class InternalCreateParamTupleFromOptionObject() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateParamTupleFromOptionObject";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    option: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targT,
      targs => Array[targT],
      args => Array[option],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = targT;
  }
}

class InternalCreateParamTupleFromOptionString() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateParamTupleFromOptionString";

  static fun call(
    fs: mutable O.FunSpecializer,
    option: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Unsafe.RawStorage"),
        DeepFrozen(),
        Array[tString],
      ),
      args => Array[option],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Unsafe.RawStorage"),
      Array[tString],
      DeepFrozen(),
    );
  }
}

class InternalCreateRetValueFromMixed() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateRetValueFromMixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    m: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      args => Array[m],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class InternalCreateVarrayFromItems() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalCreateVarrayFromItems";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    i: Type,
    items: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Vector.HH_varray2"),
        DeepFrozen(),
        Array[t],
      ),
      targs => Array[t, i],
      args => Array[items],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass, i: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t, i]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Vector.HH_varray2"),
      Array[t],
      DeepFrozen(),
    );
  }
}

class InternalMapGetItems() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalMapGetItems";

  static fun call(
    fs: mutable O.FunSpecializer,
    targK: Type,
    targV: Type,
    src: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Iterator"),
        Mutable(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Tuple2"),
            DeepFrozen(),
            Array[targK, targV],
          ),
        ],
      ),
      targs => Array[targK, targV],
      args => Array[src],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    targK: Tclass,
    targV: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targK, targV]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Iterator"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("Tuple2"),
          Array[targK, targV],
          DeepFrozen(),
        ),
      ],
      Mutable(),
    );
  }
}

class InternalSetGetValues() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.internalSetGetValues";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    src: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Iterator"),
        Mutable(),
        Array[t],
      ),
      targs => Array[t],
      args => Array[src],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(FrontEndLazyGClass("Iterator"), Array[t], Mutable());
  }
}

class PropertyGetHelper extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.propertyGetHelper";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    targU: Type,
    ptr: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targU,
      targs => Array[targT, targU],
      args => Array[ptr, field],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    targT: Tclass,
    targU: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT, targU]);
    _ = targU;
  }
}

class PropertySetHelper extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.propertySetHelper";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    targU: Type,
    ptr: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT, targU],
      args => Array[ptr, field, value],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    targT: Tclass,
    targU: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT, targU]);
  }
}

class ThrowUnknownHhvmTypeError() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.throwUnknownHhvmTypeError";

  static fun call(
    fs: mutable O.FunSpecializer,
    actual: O.MaybeExists<O.InstrTree>,
    name: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      args => Array[actual, name],
      pos,
      returns => false,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

class TupleHelperAppend() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.tupleHelperAppend";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      args => Array[obj, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

class TupleHelperCreate() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.tupleHelperCreate";

  static fun call(
    fs: mutable O.FunSpecializer,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("HhvmInterop.TupleHelper"),
        Mutable(),
        Array[],
      ),
      args => Array[],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("HhvmInterop.TupleHelper"),
      Array[],
      Mutable(),
    );
  }
}

class TupleHelperGet() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop.tupleHelperGet";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    index: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      args => Array[obj, index],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

module end;

module HhvmInterop_Gather;

class DeserializeArray() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeArray";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Array"),
            DeepFrozen(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Array"), Array[t], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeBool() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeBool";

  static fun call(
    fs: mutable O.FunSpecializer,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tBool, tInt],
      ),
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tBool, tInt],
      DeepFrozen(),
    );
  }
}

class DeserializeKBase extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeKBase";

  static fun call(
    fs: mutable O.FunSpecializer,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Runtime.GCPointer"),
            Mutable(),
            Array[],
          ),
          tInt,
        ],
      ),
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("Runtime.GCPointer"),
          Array[],
          Mutable(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeLambda() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeLambda";

  static fun call(
    fs: mutable O.FunSpecializer,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("HH.Lambda"),
            DeepFrozen(),
            Array[],
          ),
          tInt,
        ],
      ),
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("HH.Lambda"), Array[], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeMap() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeMap";

  static fun call(
    fs: mutable O.FunSpecializer,
    tk: Type,
    tv: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Map"),
            DeepFrozen(),
            Array[tk, tv],
          ),
          tInt,
        ],
      ),
      targs => Array[tk, tv],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, tk: Tclass, tv: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[tk, tv]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Map"), Array[tk, tv], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeMixed() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeMixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    validTypeMask: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("HH.Mixed"),
            DeepFrozen(),
            Array[],
          ),
          tInt,
        ],
      ),
      args => Array[data, offset, validTypeMask],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("HH.Mixed"), Array[], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeOption() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeOption";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Option"),
            DeepFrozen(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Option"), Array[t], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeOptionOption() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeOptionOption";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Option"),
            DeepFrozen(),
            Array[
              fs.specializer.specializeType2(
                FrontEndLazyGClass("Option"),
                DeepFrozen(),
                Array[t],
              ),
            ],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("Option"),
          Array[
            s.getTclass2(FrontEndLazyGClass("Option"), Array[t], DeepFrozen()),
          ],
          DeepFrozen(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeProxy() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeProxy";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[t, tInt],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[t, tInt],
      DeepFrozen(),
    );
  }
}

class DeserializeSet() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeSet";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Set"),
            DeepFrozen(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Set"), Array[t], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeTuple2() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeTuple2";

  static fun call(
    fs: mutable O.FunSpecializer,
    t0: Type,
    t1: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Tuple2"),
            DeepFrozen(),
            Array[t0, t1],
          ),
          tInt,
        ],
      ),
      targs => Array[t0, t1],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t0: Tclass, t1: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t0, t1]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Tuple2"), Array[t0, t1], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeTuple3() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeTuple3";

  static fun call(
    fs: mutable O.FunSpecializer,
    t0: Type,
    t1: Type,
    t2: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Tuple3"),
            DeepFrozen(),
            Array[t0, t1, t2],
          ),
          tInt,
        ],
      ),
      targs => Array[t0, t1, t2],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    t0: Tclass,
    t1: Tclass,
    t2: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t0, t1, t2]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("Tuple3"),
          Array[t0, t1, t2],
          DeepFrozen(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeTuple4() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeTuple4";

  static fun call(
    fs: mutable O.FunSpecializer,
    t0: Type,
    t1: Type,
    t2: Type,
    t3: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Tuple4"),
            DeepFrozen(),
            Array[t0, t1, t2, t3],
          ),
          tInt,
        ],
      ),
      targs => Array[t0, t1, t2, t3],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    t0: Tclass,
    t1: Tclass,
    t2: Tclass,
    t3: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t0, t1, t2, t3]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("Tuple4"),
          Array[t0, t1, t2, t3],
          DeepFrozen(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeUnorderedMap() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeUnorderedMap";

  static fun call(
    fs: mutable O.FunSpecializer,
    tk: Type,
    tv: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("UnorderedMap"),
            DeepFrozen(),
            Array[tk, tv],
          ),
          tInt,
        ],
      ),
      targs => Array[tk, tv],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, tk: Tclass, tv: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[tk, tv]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("UnorderedMap"),
          Array[tk, tv],
          DeepFrozen(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeUnorderedSet() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeUnorderedSet";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("UnorderedSet"),
            DeepFrozen(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("UnorderedSet"),
          Array[t],
          DeepFrozen(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class DeserializeVector() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.deserializeVector";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Vector"),
            DeepFrozen(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Vector"), Array[t], DeepFrozen()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class FetchRawScalar extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.fetchRawScalar";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[t, tInt],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[t, tInt],
      DeepFrozen(),
    );
  }
}

class Gather() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.gather";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    heapObject: O.MaybeExists<O.InstrTree>,
    classId: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => t,
      targs => Array[t],
      args => Array[heapObject, classId],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = t;
  }
}

class GatherCleanup() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.gatherCleanup";

  static fun call(
    fs: mutable O.FunSpecializer,
    handle: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{fs, typ => tVoid, args => Array[handle], pos}
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

class GatherCollect() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.gatherCollect";

  static fun call(
    fs: mutable O.FunSpecializer,
    object: O.MaybeExists<O.InstrTree>,
    classId: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Runtime.NonGCPointer"),
            DeepFrozen(),
            Array[],
          ),
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Runtime.NonGCPointer"),
            DeepFrozen(),
            Array[],
          ),
        ],
      ),
      args => Array[object, classId],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("Runtime.NonGCPointer"),
          Array[],
          DeepFrozen(),
        ),
        s.getTclass2(
          FrontEndLazyGClass("Runtime.NonGCPointer"),
          Array[],
          DeepFrozen(),
        ),
      ],
      DeepFrozen(),
    );
  }
}

class GatherConvert extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.gatherConvert";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[t, tInt],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[t, tInt],
      DeepFrozen(),
    );
  }
}

class MDeserializeArray() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.mDeserializeArray";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Array"),
            Mutable(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Array"), Array[t], Mutable()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class MDeserializeKBase extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.mDeserializeKBase";

  static fun call(
    fs: mutable O.FunSpecializer,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Runtime.GCPointer"),
            Mutable(),
            Array[],
          ),
          tInt,
        ],
      ),
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("Runtime.GCPointer"),
          Array[],
          Mutable(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class MDeserializeMap() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.mDeserializeMap";

  static fun call(
    fs: mutable O.FunSpecializer,
    tk: Type,
    tv: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Map"),
            Mutable(),
            Array[tk, tv],
          ),
          tInt,
        ],
      ),
      targs => Array[tk, tv],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, tk: Tclass, tv: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[tk, tv]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Map"), Array[tk, tv], Mutable()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class MDeserializeSet() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.mDeserializeSet";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Set"),
            Mutable(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[s.getTclass2(FrontEndLazyGClass("Set"), Array[t], Mutable()), tInt],
      DeepFrozen(),
    );
  }
}

class MDeserializeUnorderedMap() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.mDeserializeUnorderedMap";

  static fun call(
    fs: mutable O.FunSpecializer,
    tk: Type,
    tv: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("UnorderedMap"),
            Mutable(),
            Array[tk, tv],
          ),
          tInt,
        ],
      ),
      targs => Array[tk, tv],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, tk: Tclass, tv: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[tk, tv]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(
          FrontEndLazyGClass("UnorderedMap"),
          Array[tk, tv],
          Mutable(),
        ),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class MDeserializeUnorderedSet() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.mDeserializeUnorderedSet";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("UnorderedSet"),
            Mutable(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("UnorderedSet"), Array[t], Mutable()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class MDeserializeVector() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.mDeserializeVector";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    data: O.MaybeExists<O.InstrTree>,
    offset: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Vector"),
            Mutable(),
            Array[t],
          ),
          tInt,
        ],
      ),
      targs => Array[t],
      args => Array[data, offset],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Vector"), Array[t], Mutable()),
        tInt,
      ],
      DeepFrozen(),
    );
  }
}

class ThrowUnknownClassIdError() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_Gather.throwUnknownClassIdError";

  static fun call(
    fs: mutable O.FunSpecializer,
    classId: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{fs, typ => tVoid, args => Array[classId], pos}
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

module end;

module HhvmInterop_ObjectCons;

class Create() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_ObjectCons.create";

  static fun call(
    fs: mutable O.FunSpecializer,
    classId: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Runtime.HhvmHandle"),
        DeepFrozen(),
        Array[],
      ),
      args => Array[classId],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Runtime.HhvmHandle"),
      Array[],
      DeepFrozen(),
    );
  }
}

class Finish() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_ObjectCons.finish";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{fs, typ => tVoid, args => Array[obj], pos}
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

class SetFieldMixed() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_ObjectCons.setFieldMixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    slot: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      args => Array[obj, slot, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

module end;

module HhvmInterop_PropertyGetHelper;

class CheckRetValueType() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.checkRetValueType";

  static fun call(
    fs: mutable O.FunSpecializer,
    tup: O.MaybeExists<O.InstrTree>,
    validTypeMask: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      args => Array[tup, validTypeMask],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

class InternalBitcastFromInt extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalBitcastFromInt";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    i: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targT,
      targs => Array[targT],
      args => Array[i],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = targT;
  }
}

class InternalCreateFromRetValue extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateFromRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    v: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => t,
      targs => Array[t],
      args => Array[v],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[t]);
    _ = t;
  }
}

class InternalCreateLambdaFromRetValue() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateLambdaFromRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    t: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("HH.Lambda"),
        DeepFrozen(),
        Array[],
      ),
      args => Array[t],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(FrontEndLazyGClass("HH.Lambda"), Array[], DeepFrozen());
  }
}

class InternalCreateNonNullableFromRetValue extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateNonNullableFromRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => targT,
      targs => Array[targT],
      args => Array[value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = targT;
  }
}

class InternalCreateNullableFromRetValue() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateNullableFromRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    t: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Nullable"),
        DeepFrozen(),
        Array[targT],
      ),
      targs => Array[targT],
      args => Array[t],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Nullable"),
      Array[targT],
      DeepFrozen(),
    );
  }
}

class InternalCreateOptionFromRetValue() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateOptionFromRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    t: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Option"),
        DeepFrozen(),
        Array[targT],
      ),
      targs => Array[targT],
      args => Array[t],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(FrontEndLazyGClass("Option"), Array[targT], DeepFrozen());
  }
}

class InternalCreateOptionOptionFromRetValue() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateOptionOptionFromRetValue";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    t: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Option"),
        DeepFrozen(),
        Array[
          fs.specializer.specializeType2(
            FrontEndLazyGClass("Option"),
            DeepFrozen(),
            Array[targT],
          ),
        ],
      ),
      targs => Array[targT],
      args => Array[t],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Option"),
      Array[
        s.getTclass2(FrontEndLazyGClass("Option"), Array[targT], DeepFrozen()),
      ],
      DeepFrozen(),
    );
  }
}

class InternalCreateRetValueFromOption() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateRetValueFromOption";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    option: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      targs => Array[targT],
      args => Array[option],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class InternalCreateRetValueFromOptionOption() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertyGetHelper.internalCreateRetValueFromOptionOption";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    option: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      targs => Array[targT],
      args => Array[option],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

module end;

module HhvmInterop_PropertySetHelper;

class InternalSetLambdaProperty() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertySetHelper.internalSetLambdaProperty";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT],
      args => Array[obj, field, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
  }
}

class InternalSetMixedProperty() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertySetHelper.internalSetMixedProperty";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT],
      args => Array[obj, field, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer, targT: Tclass): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT]);
  }
}

class InternalSetNullableProperty() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertySetHelper.internalSetNullableProperty";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    targU: Type,
    obj: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT, targU],
      args => Array[obj, field, value],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    targT: Tclass,
    targU: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT, targU]);
  }
}

class InternalSetOptionOptionProperty() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertySetHelper.internalSetOptionOptionProperty";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    targU: Type,
    obj: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT, targU],
      args => Array[obj, field, value],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    targT: Tclass,
    targU: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT, targU]);
  }
}

class InternalSetOptionProperty() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertySetHelper.internalSetOptionProperty";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    targU: Type,
    obj: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT, targU],
      args => Array[obj, field, value],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    targT: Tclass,
    targU: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT, targU]);
  }
}

class InternalSetProperty extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_PropertySetHelper.internalSetProperty";

  static fun call(
    fs: mutable O.FunSpecializer,
    targT: Type,
    targU: Type,
    obj: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      targs => Array[targT, targU],
      args => Array[obj, field, value],
      pos,
    }
  }

  static fun request(
    s: mutable O.Specializer,
    targT: Tclass,
    targU: Tclass,
  ): void {
    _ = s;
    s.requestFunction(static::funName(), Array[targT, targU]);
  }
}

module end;

module HhvmInterop_ShapeCons;

class Create() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_ShapeCons.create";

  static fun call(
    fs: mutable O.FunSpecializer,
    shapeId: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitCallFunction{
      fs,
      typ => fs.specializer.specializeType2(
        FrontEndLazyGClass("Runtime.HhvmShapeHandle"),
        DeepFrozen(),
        Array[],
      ),
      args => Array[shapeId],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
    _ = s.getTclass2(
      FrontEndLazyGClass("Runtime.HhvmShapeHandle"),
      Array[],
      DeepFrozen(),
    );
  }
}

class Finish() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_ShapeCons.finish";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{fs, typ => tVoid, args => Array[obj], pos}
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

class SetFieldMixed() extends O.CallableIntrinsic {
  const name: String = "HhvmInterop_ShapeCons.setFieldMixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    slot: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitCallFunction{
      fs,
      typ => tVoid,
      args => Array[obj, slot, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    s.requestFunction(static::funName(), Array[]);
  }
}

module end;

module SkipRuntime;

class GetObjectType() extends O.CallableIntrinsic {
  const name: String = "SKIP_HHVM_Object_getType";

  static fun call(
    fs: mutable O.FunSpecializer,
    handle: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{
      fs,
      retType => tString,
      args => Array[handle],
      pos,
      allocAmount => AllocBounded(),
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = tString;
  }
}

class HhvmArrayRetCreate() extends O.CallableIntrinsic {
  const name: String = "SKIP_HhvmArrayRet_create";

  static fun call(
    fs: mutable O.FunSpecializer,
    var: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitNamedCall{
      fs,
      retType => tVoid,
      args => Array[var, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
  }
}

class HhvmObjectRetCreate() extends O.CallableIntrinsic {
  const name: String = "SKIP_HhvmObjectRet_create";

  static fun call(
    fs: mutable O.FunSpecializer,
    var: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitNamedCall{
      fs,
      retType => tVoid,
      args => Array[var, value],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
  }
}

class HhvmVariantFromMixed() extends O.CallableIntrinsic {
  const name: String = "SKIP_HhvmVariant_fromMixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    variant: O.MaybeExists<O.InstrTree>,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): void {
    _ = static::emitNamedCall{
      fs,
      retType => tVoid,
      args => Array[variant, value],
      pos,
      allocAmount => AllocBounded(),
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
  }
}

class HhvmVariantToRetValue() extends O.CallableIntrinsic {
  const name: String = "SKIP_HHVM_Nullable_getMixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{
      fs,
      retType => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      args => Array[obj],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class MaybeConvertToArray() extends O.CallableIntrinsic {
  const name: String = "SKIP_HHVM_MaybeConvertToArray";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{
      fs,
      retType => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      args => Array[obj],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class ObjectGetFieldMixed() extends O.CallableIntrinsic {
  const name: String = "SKIP_HHVM_Object_getField_Mixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    handle: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{
      fs,
      retType => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      args => Array[handle, field],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class ShapeGetFieldMixed() extends O.CallableIntrinsic {
  const name: String = "SKIP_HHVM_Shape_getField_Mixed";

  static fun call(
    fs: mutable O.FunSpecializer,
    handle: O.MaybeExists<O.InstrTree>,
    field: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{
      fs,
      retType => fs.specializer.specializeType2(
        FrontEndLazyGClass("Tuple2"),
        DeepFrozen(),
        Array[tInt, tInt],
      ),
      args => Array[handle, field],
      pos,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[tInt, tInt],
      DeepFrozen(),
    );
  }
}

class StringExtractData() extends O.CallableIntrinsic {
  const name: String = "SKIP_string_extractData";

  static fun call(
    fs: mutable O.FunSpecializer,
    handle: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{fs, retType => tString, args => Array[handle], pos}
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = tString;
  }
}

class WrapHhvmArray() extends O.CallableIntrinsic {
  const name: String = "SKIP_Obstack_wrapHhvmArray";

  static fun call(
    fs: mutable O.FunSpecializer,
    array: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{
      fs,
      retType => tHhvmShapeHandle,
      args => Array[array],
      pos,
      canThrow => false,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = tHhvmShapeHandle;
  }
}

class WrapHhvmObject() extends O.CallableIntrinsic {
  const name: String = "SKIP_Obstack_wrapHhvmObject";

  static fun call(
    fs: mutable O.FunSpecializer,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    static::emitNamedCall{
      fs,
      retType => tHhvmHandle,
      args => Array[obj],
      pos,
      canThrow => false,
    }
  }

  static fun request(s: mutable O.Specializer): void {
    _ = s;
    _ = tHhvmHandle;
  }
}
