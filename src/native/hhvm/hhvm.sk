/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module alias I = OuterIst;
module alias O = OuterIstToIR;
module alias F = FunctionTree;

module Svmi;

extension base class ParamType {
  fun asNullable(): ParamType
  | ParamTypeVoid _ -> ParamTypeVoid()
  | ParamTypeBool _ -> ParamTypeNullableBool()
  | ParamTypeInt64 _ -> ParamTypeNullableInt64()
  | ParamTypeFloat64 _ -> ParamTypeNullableFloat64()
  | ParamTypeString _ -> ParamTypeNullableString()
  | ParamTypeHhvmObject _ -> ParamTypeNullableHhvmObject()
  | ParamTypeHhvmArray _ -> ParamTypeNullableHhvmArray()
  | ParamTypeMixed _ -> ParamTypeMixed()
  | ParamTypeNullableBool _ -> ParamTypeNullableBool()
  | ParamTypeNullableInt64 _ -> ParamTypeNullableInt64()
  | ParamTypeNullableFloat64 _ -> ParamTypeNullableFloat64()
  | ParamTypeNullableString _ -> ParamTypeNullableString()
  | ParamTypeNullableHhvmObject _ -> ParamTypeNullableHhvmObject()
  | ParamTypeNullableHhvmArray _ -> ParamTypeNullableHhvmArray()

  // Return true if the given ParamType requires pushing a separate 'null' bool
  // or if pushing a 0 is good enough to represent null.
  fun needsSeparateNull(): Bool
  | ParamTypeVoid _ -> false
  | ParamTypeBool _ -> true
  | ParamTypeNullableBool _ -> false
  | ParamTypeInt64 _ -> true
  | ParamTypeNullableInt64 _ -> false
  | ParamTypeFloat64 _ -> true
  | ParamTypeNullableFloat64 _ -> false
  | ParamTypeString _ -> false
  | ParamTypeNullableString _ -> false
  | ParamTypeHhvmObject _ -> false
  | ParamTypeNullableHhvmObject _ -> false
  | ParamTypeHhvmArray _ -> false
  | ParamTypeNullableHhvmArray _ -> false
  | ParamTypeMixed _ -> true

  static fun fromType(
    fs: mutable O.FunSpecializer,
    t: Type,
    allowVoid: Bool,
    pos: Pos,
  ): ParamType {
    s = fs.specializer;

    if (Hhvm.isNullableType(s, t)) {
      code = ParamType::fromType(
        fs,
        Hhvm.getNullableTarg(s, t, pos),
        allowVoid,
        pos,
      );
      code.asNullable();
    } else if (
      HhvmInterop.isArraylike(s, t) ||
      HhvmInterop.isMaplike(s, t) ||
      HhvmInterop.isSetlike(s, t)
    ) {
      ParamTypeHhvmArray()
    } else if (Hhvm.isOptionType(s, t)) {
      subtype = Hhvm.getOptionTarg(s, t, pos);
      if (Hhvm.isOptionType(fs, subtype)) {
        // ??T
        !subtype = Hhvm.getOptionTarg(s, subtype, pos);
      };
      code = ParamType::fromType(fs, subtype, allowVoid, pos);
      code.asNullable();
    } else if (t == tVoid) {
      if (!allowVoid) {
        pos.die("Unexpected void parameter.")
      };
      ParamTypeVoid()
    } else if (t == tBool) {
      ParamTypeBool()
    } else if (t == tInt) {
      ParamTypeInt64()
    } else if (t == tFloat) {
      ParamTypeFloat64()
    } else if (t == tString) {
      ParamTypeString()
    } else if (
      Hhvm.isHhvmHandle(t) ||
      Hhvm.isHhvmImport(s, t, pos) ||
      Hhvm.isHhvmCopy(s, t, pos)
    ) {
      ParamTypeHhvmObject()
    } else if (
      Hhvm.isHhvmArray(s, t, pos) ||
      Hhvm.isHhvmShape(s, t, pos) ||
      Hhvm.isHhvmShapeCopy(s, t, pos) ||
      HhvmInterop.isTuple(s, t)
    ) {
      ParamTypeHhvmArray()
    } else if (Hhvm.isMixedSubclass(s, t)) {
      ParamTypeMixed()
    } else if (Hhvm.isHHLambdaSubclass(s, t)) {
      ParamTypeMixed()
    } else {
      pos.die(`Do not know how to describe type ${t} for the HHVM plugin.`)
    }
  }

  private fun mask(): Int {
    1.shl(this.code())
  }

  static fun maskFromType(
    fs: mutable O.FunSpecializer,
    t: Type,
    pos: Pos,
  ): Int {
    s = fs.specializer;

    if (Hhvm.isMixedSubclass(fs, t)) {
      mask = 0;
      _ = t.forEachConcreteSubtype(fs, sc -> {
        value = sc.id.id match {
        | "HH.Null" -> ParamTypeVoid()
        | "HH.Bool" -> ParamTypeBool()
        | "HH.Float" -> ParamTypeFloat64()
        | "HH.Int" -> ParamTypeInt64()
        | "HH.String" -> ParamTypeString()
        | "HH.Darray" -> ParamTypeHhvmArray()
        | "HH.Dict" -> ParamTypeHhvmArray()
        | "HH.Varray" -> ParamTypeHhvmArray()
        | "HH.Vec" -> ParamTypeHhvmArray()
        | "HH.Keyset" -> ParamTypeHhvmArray()
        | "HH.Map" -> ParamTypeHhvmObject()
        | "HH.Vector" -> ParamTypeHhvmObject()
        | "HH.Set" -> ParamTypeHhvmObject()
        | "HH.ProxyObject" -> ParamTypeHhvmObject()
        | _ -> pos.die(`${sc.id}: Unknown concrete subclass of HH.Mixed`)
        };
        !mask = mask.or(value.mask());
        true
      });
      return mask;
    };

    if (Hhvm.isHHLambdaSubclass(fs, t)) {
      return ParamTypeString().mask().or(ParamTypeHhvmObject().mask());
    };

    if (Hhvm.isHHLambdaSubclass(fs, t)) {
      return ParamTypeString().mask().or(ParamTypeHhvmObject().mask());
    };

    if (Hhvm.isOptionType(fs, t)) {
      targ = Hhvm.getOptionTarg(s, t, pos);
      return ParamTypeVoid().mask().or(static::maskFromType(fs, targ, pos));
    };

    if (Hhvm.isHhvmHandle(t)) {
      // HhvmHandle can be either Object or Array
      return ParamTypeHhvmObject().mask().or(ParamTypeHhvmArray().mask());
    };

    1.shl(ParamType::fromType(fs, t, false, pos).code())
  }
}

module end;
// -----------------------------------------------------------------------------
module OuterIstToIR;

base class HasIntrinsicName {
  deferred const name: String;

  static deferred fun funName(): LazyGFun {
    O.FrontEndLazyGFun{frontEndName => static::name}
  }
}

// Helper base class for intrinsics which can be called directly from other
// intrinsics.
base class CallableIntrinsic extends HasIntrinsicName {
  protected static deferred fun emitCallFunction{
    fs: mutable O.FunSpecializer,
    typ: Type,
    targs: Array<Type> = Array[],
    args: Array<MaybeExists<InstrTree>>,
    pos: Pos,
    returns: Bool = true,
  }: MaybeExists<InstrTree> {
    smap = fs.getSpecializedFunSMap(targs);
    name = fs.computeSFunctionID(static::funName(), smap, pos);
    F.emitCallFunction{fs, name, args, smap, typ, pos, returns};
  }

  protected static deferred fun emitNamedCall{
    fs: mutable O.FunSpecializer,
    retType: Type,
    args: Array<MaybeExists<InstrTree>>,
    pos: Pos,
    canThrow: Bool = true,
    allocAmount: AllocAmount = AllocUnbounded(),
  }: MaybeExists<InstrTree> {
    F.emitNamedCall{
      fs,
      typ => retType,
      name => static::name,
      args,
      pos,
      canThrow,
      allocAmount,
    }
  }
}

// GCustomIntrinsic is a helper for writing intrinsics which only need to be
// implemented in the GIR layer.  This is done by overriding emitBody().
base class GCustomIntrinsic final {} extends ConcreteLazyGFun, HasIntrinsicName{
  fun compiledFunType(): String {
    static::name
  }

  static deferred fun make(
    funInfo: GFunInfo,
    params: Array<ParameterInfo>,
  ): this {
    static{funInfo, params}
  }
}

// CustomIntrinsic is a helper for writing intrinsics which are implemented in
// the IR layer.  This is done by overriding emitIR().
base class CustomIntrinsic extends GCustomIntrinsic {
  protected fun emitBody(emitter: mutable OuterIstEmitter): void {
    pos = this.funInfo.pos;
    emitter.emitBindParameters();
    emitter.emitReturn(
      emitter.emitInstr(
        GCustomInstr{
          typ => this.funInfo.funType.returnType,
          pos,
          emit => (call, fs) ~> {
            res = this.emitIR(call, fs);
            fs.setValue(call, res);
          },
          request => Some(this.requestFunctions),
          args => emitter.params,
        },
      ),
      pos,
    );
  }

  protected fun emitIR(
    call: GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree>;

  protected overridable fun requestFunctions(
    _s: mutable Specializer,
    _targs: Array<Tclass>,
    _tparamEnv: UnorderedMap<GTparam, Tclass>,
  ): void {
    void
  }
}

// This is the emitter for GCallHhvmFunction - handling @hhvm_import functions
mutable private class EmitCallHhvmFunction{} {
  static fun emitIR(
    fs: mutable O.FunSpecializer,
    call: GCallHhvmFunction,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;
    retType = fs.specializeType(call.typ);

    callArgs = mutable Vector<MaybeExists<InstrTree>>[];

    // extern SVMI(ParamValue) SKIP_HHVM_callFunction(
    //   SkipHhvmObjectDataHandle* object,
    //   SkipString function,
    //   SkipString paramTypes,
    //   ...);

    // For method calls need to emit object pointer
    callArgs.push(static::getObjectHandle(fs, call, pos));

    callArgs.push(F.constantString{fs, value => call.hhvmName});

    args = call.args.map(v -> fs.getValue(v));
    argTypes = call.args.map(v -> fs.specializeType(v.getType()));
    (typeString, typeArgs) = static::computeSvmiTypes(
      fs,
      retType,
      argTypes,
      args,
      pos,
    );

    callArgs.push(F.constantString{fs, value => typeString});
    callArgs.extend(typeArgs);

    // SKIP_HHVM_callFunction() returns a ParamValue union, which C treats
    // as an i64 and then casts.

    tupleType = Hhvm.getSkipRetValueType(fs);
    result = F.emitNamedCall{
      fs,
      typ => tupleType,
      pos,
      name => "SKIP_HHVM_callFunction",
      args => callArgs.toArray(),
      llvmRetType => "{i64, i64} (i8*, i8*, i8*, ...)",
    };

    callVal = if (Hhvm.isNullableType(s, retType)) {
      HhvmInterop_PropertyGetHelper.InternalCreateNullableFromRetValue::call(
        fs,
        Hhvm.getNullableTarg(s, retType, pos),
        result,
        pos,
      )
    } else if (Hhvm.isOptionType(fs, retType)) {
      HhvmInterop_PropertyGetHelper.InternalCreateOptionFromRetValue::call(
        fs,
        Hhvm.getOptionTarg(s, retType, pos),
        result,
        pos,
      )
    } else if (Hhvm.isHhvmCopy(s, retType, pos)) {
      HhvmInterop.CopyFromHhvm::call(
        fs,
        retType,
        HhvmInterop_PropertyGetHelper.InternalCreateNonNullableFromRetValue::call(
          fs,
          tHhvmHandle,
          result,
          pos,
        ),
        pos,
      )
    } else if (Hhvm.isHhvmShapeCopy(s, retType, pos)) {
      HhvmInterop.CopyFromHhvm::call(
        fs,
        retType,
        HhvmInterop_PropertyGetHelper.InternalCreateNonNullableFromRetValue::call(
          fs,
          tHhvmShapeHandle,
          result,
          pos,
        ),
        pos,
      )
    } else if (retType != tVoid) {
      HhvmInterop_PropertyGetHelper.InternalCreateNonNullableFromRetValue::call(
        fs,
        retType,
        result,
        pos,
      );
    } else {
      Exists(O.kVoidInstrTree)
    };

    callVal
  }

  static fun requestFunctions(
    s: mutable Specializer,
    call: GCallHhvmFunction,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
    pos: Pos,
  ): void {
    typ = s.getTclass3(call.typ, tparamEnv);

    if (Hhvm.isNullableType(s, typ)) {
      HhvmInterop_PropertyGetHelper.InternalCreateNullableFromRetValue::request(
        s,
        Hhvm.tcGetNullableTarg(s, typ, pos),
      );
    } else if (Hhvm.isOptionType(s, typ)) {
      HhvmInterop_PropertyGetHelper.InternalCreateOptionFromRetValue::request(
        s,
        Hhvm.tcGetOptionTarg(s, typ, pos),
      )
    } else if (Hhvm.isHhvmCopy(s, typ, pos)) {
      HhvmInterop_PropertyGetHelper.InternalCreateNonNullableFromRetValue::request(
        s,
        tHhvmHandle,
      );
      HhvmInterop.CopyFromHhvm::request(s, typ);
    } else if (Hhvm.isHhvmShapeCopy(s, typ, pos)) {
      HhvmInterop_PropertyGetHelper.InternalCreateNonNullableFromRetValue::request(
        s,
        tHhvmShapeHandle,
      );
      HhvmInterop.CopyFromHhvm::request(s, typ);
    } else if (typ != tVoid) {
      HhvmInterop_PropertyGetHelper.InternalCreateNonNullableFromRetValue::request(
        s,
        typ,
      );
    };

    call.object match {
    | Some(o) ->
      HhvmInterop.FetchProxyPointer::request(
        s,
        s.getTclass3(o.getType(), tparamEnv),
      )
    | None() -> void
    };

    for (arg in call.args) {
      argType = s.getTclass3(arg.getType(), tparamEnv);

      if (Hhvm.isNullableType(s, argType)) {
        targ = Hhvm.tcGetNullableTarg(s, argType, pos);
        if (Hhvm.isHhvmProxy(s, targ, pos)) {
          HhvmInterop.InternalCreateParamTupleFromNullableObject::request(
            s,
            targ,
          );
        } else if (targ == tString) {
          HhvmInterop.InternalCreateParamTupleFromNullableString::request(s);
        } else {
          HhvmInterop.InternalCreateParamTupleFromNullableT::request(s, targ)
        }
      } else if (Hhvm.isOptionType(s, argType)) {
        targ = Hhvm.tcGetOptionTarg(s, argType, pos);
        if (Hhvm.isHhvmProxy(s, targ, pos)) {
          HhvmInterop.InternalCreateParamTupleFromOptionObject::request(
            s,
            targ,
          );
        } else if (targ == tString) {
          HhvmInterop.InternalCreateParamTupleFromOptionString::request(s);
        } else if (
          Hhvm.isHhvmCopy(s, targ, pos) ||
          Hhvm.isHhvmShapeCopy(s, targ, pos)
        ) {
          HhvmInterop.CopyOptionToHhvm::request(s, targ)
        } else {
          HhvmInterop.InternalCreateParamTupleFromOption::request(s, targ)
        }
      } else if (Hhvm.isHhvmProxy(s, argType, pos)) {
        HhvmInterop.FetchProxyPointer::request(s, argType);
      } else if (
        Hhvm.isHhvmCopy(s, argType, pos) ||
        Hhvm.isHhvmShapeCopy(s, argType, pos) ||
        HhvmInterop.isTuple(s, argType)
      ) {
        HhvmInterop.CopyToHhvm::request(s, argType);
      } else if (Hhvm.isMixedSubclass(s, argType)) {
        HhvmInterop.InternalCreateRetValueFromMixed::request(s);
      }
    };
  }

  private static fun computeSvmiTypes(
    fs: mutable O.FunSpecializer,
    retType: Type,
    argTypes: Array<Type>,
    args: Array<MaybeExists<InstrTree>>,
    pos: Pos,
  ): (String, Array<MaybeExists<InstrTree>>) {
    s = fs.specializer;

    retChar = Char::fromCode(
      (if (Hhvm.isNullableType(s, retType)) {
        Svmi.ParamType::fromType(
          fs,
          Hhvm.getNullableTarg(s, retType, pos),
          true,
          pos,
        ).asNullable()
      } else {
        Svmi.ParamType::fromType(fs, retType, true, pos)
      }).code(),
    );

    paramChars = mutable Vector[retChar];
    fnArgs = mutable Vector[];
    for (i in argTypes.zip(args)) {
      (argType, arg) = i;
      paramChars.push(
        Char::fromCode(
          {
            svmiCode = Svmi.ParamType::fromType(fs, argType, false, pos);

            fnArgs.push(
              if (Hhvm.isNullableType(s, argType)) {
                targ = Hhvm.getNullableTarg(s, argType, pos);
                if (Hhvm.isHhvmProxy(s, targ, pos)) {
                  HhvmInterop.InternalCreateParamTupleFromNullableObject::call(
                    fs,
                    targ,
                    arg,
                    pos,
                  )
                } else if (targ == tString) {
                  HhvmInterop.InternalCreateParamTupleFromNullableString::call(
                    fs,
                    arg,
                    pos,
                  )
                } else {
                  HhvmInterop.InternalCreateParamTupleFromNullableT::call(
                    fs,
                    targ,
                    arg,
                    pos,
                  )
                }
              } else if (Hhvm.isOptionType(fs, argType)) {
                targ = Hhvm.getOptionTarg(s, argType, pos);
                if (Hhvm.isHhvmProxy(s, targ, pos)) {
                  HhvmInterop.InternalCreateParamTupleFromOptionObject::call(
                    fs,
                    targ,
                    arg,
                    pos,
                  )
                } else if (targ == tString) {
                  HhvmInterop.InternalCreateParamTupleFromOptionString::call(
                    fs,
                    arg,
                    pos,
                  )
                } else if (
                  Hhvm.isHhvmCopy(s, targ, pos) ||
                  Hhvm.isHhvmShapeCopy(s, targ, pos)
                ) {
                  HhvmInterop.CopyOptionToHhvm::call(fs, targ, arg, pos)
                } else {
                  HhvmInterop.InternalCreateParamTupleFromOption::call(
                    fs,
                    targ,
                    arg,
                    pos,
                  )
                }
              } else if (Hhvm.isHhvmProxy(s, argType, pos)) {
                HhvmInterop.FetchProxyPointer::call(fs, argType, arg, pos)
              } else if (
                Hhvm.isHhvmCopy(s, argType, pos) ||
                Hhvm.isHhvmShapeCopy(s, argType, pos) ||
                HhvmInterop.isTuple(s, argType)
              ) {
                HhvmInterop.CopyToHhvm::call(fs, argType, arg, pos)
              } else if (Hhvm.isMixedSubclass(fs, argType)) {
                HhvmInterop.InternalCreateRetValueFromMixed::call(fs, arg, pos)
              } else {
                arg
              },
            );

            svmiCode.code()
          },
        ),
      );
    };

    (String::fromChars(paramChars.toArray()), fnArgs.toArray())
  }

  // This returns the unwrapped tHhvmHandle for the object which an HHVM method
  // is called on or zero for a static or global function.
  private static fun getObjectHandle(
    fs: mutable O.FunSpecializer,
    call: GCallHhvmFunction,
    pos: Pos,
  ): MaybeExists<InstrTree> {
    call.object match {
    | Some(object) ->
      HhvmInterop.FetchProxyPointer::call(
        fs,
        fs.specializeType(object.getType()),
        fs.getValue(object),
        pos,
      )
    | None() -> Exists(InstrLeaf(fs.constantZero(tHhvmHandle).id))
    }
  }
}

// This is the emitter for GCallHhvmWrappedFunction - handling @hhvm_export
// wrappers
mutable private class EmitCallHhvmWrappedFunction{} {
  static fun emitIR(
    fs: mutable O.FunSpecializer,
    call: GCallHhvmWrappedFunction,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    args = call.args.map(v -> fs.getValue(v));
    s = fs.specializer;

    smap = fs.getFunSMap(call.targs);
    targetFunctionID = fs.computeSFunctionID(call.name, smap, pos);

    targetReturnType = fs.specializeType(call.targetReturnType);
    wrapperReturnTypeCode = Svmi.ParamType::fromType(
      fs,
      targetReturnType,
      true,
      pos,
    );

    argOffset = if (
      targetReturnType == tVoid ||
      targetReturnType == tBool ||
      targetReturnType == tInt ||
      targetReturnType == tFloat
    ) {
      0
    } else {
      1
    };

    noThrow = fs.newBlockID();
    landingPad = fs.newBlockID();
    catchMatchBlock = fs.newBlockID();

    // We need to manage our own note/clear rather than letting @gc do it for us
    // because we need to pass the note to SKIP_HHVM_throwException explicitly.
    gcNote = fs.emitObstackNote{pos}.id;

    // Convert strings and objects from HHVM format to Skip format
    targetArgs = mutable Vector[];
    wrapperParamsTypeCodes = mutable Vector[];
    call.targetParamTypes.eachWithIndex((i, targetParamGType) -> {
      arg = args[i + argOffset];
      targetParamType = fs.specializeType(targetParamGType);
      (paramId, typeCode) = static::convertParameter(
        fs,
        arg,
        targetParamType,
        pos,
      );
      targetArgs.push(paramId);
      wrapperParamsTypeCodes.push(typeCode);
    });

    fs.!exportStyleReplacement = Some(
      fs.optinfo.f.exportStyle match {
      | exportStyle @ HhvmExport _ ->
        exportStyle with {
          wrapperParamTypes => wrapperParamsTypeCodes.toArray(),
          wrapperReturnType => wrapperReturnTypeCode,
        }
      | exportStyle @ _ -> exportStyle
      },
    );

    result = F.emitInvokeFunction{
      fs,
      typ => targetReturnType,
      pos,
      name => targetFunctionID,
      smap,
      args => targetArgs.toArray(),
      ifNoCatch => BlockSuccessor(noThrow),
      ifCatch => BlockSuccessor(landingPad),
    };

    fs.startNewBlock(landingPad);
    // On an uncaught exception we still need to clear the obstack!
    exc = fs.emitLandingPad{target => BlockSuccessor(catchMatchBlock), pos};

    fs.startNewBlock(catchMatchBlock);
    // We caught a skip exception - pass the exception along to
    // SKIP_HHVM_throwException() to convert it and throw as an HHVM exception.
    _ = fs.emitNamedCall{
      typ => tVoid,
      pos,
      name => "SKIP_HHVM_throwException",
      args => Array[exc.id, gcNote],
      canThrow => true,
      allocAmount => AllocUnbounded(), // XXX if we say false here, how to enforce it?
    };
    fs.emitUnreachable{pos, why => "Called SKIP_HHVM_throwException"};

    fs.startNewBlock(noThrow);

    // If we're returning a String then we need to convert it
    if (targetReturnType == tString) {
      _ = F.emitNamedCall{
        fs,
        typ => tVoid,
        pos,
        name => "SKIP_HhvmStringRet_create",
        args => Array[args[0], result],
        casts => Array["i8**"],
      };
      !targetReturnType = tVoid;
    } else if (
      Hhvm.isHhvmHandle(targetReturnType) ||
      Hhvm.isHhvmProxy(s, targetReturnType, pos)
    ) {
      if (Hhvm.isHhvmProxy(s, targetReturnType, pos)) {
        !result = HhvmInterop.FetchProxyPointer::call(
          fs,
          targetReturnType,
          result,
          pos,
        );
      };
      if (
        Hhvm.isHhvmArray(s, targetReturnType, pos) ||
        Hhvm.isHhvmShape(s, targetReturnType, pos)
      ) {
        SkipRuntime.HhvmArrayRetCreate::call(fs, args[0], result, pos)
      } else {
        SkipRuntime.HhvmObjectRetCreate::call(fs, args[0], result, pos)
      };
      !targetReturnType = tVoid;
    } else if (Hhvm.isNullableType(s, targetReturnType)) {
      static::convertNullableExportReturn(
        fs,
        args[0],
        result,
        targetReturnType,
        pos,
      );
      !targetReturnType = tVoid;
    } else if (Hhvm.isOptionType(fs, targetReturnType)) {
      static::convertOptionExportReturn(
        fs,
        args[0],
        result,
        targetReturnType,
        pos,
      )
    } else if (Hhvm.isHhvmCopy(s, targetReturnType, pos)) {
      SkipRuntime.HhvmObjectRetCreate::call(
        fs,
        args[0],
        HhvmInterop.CopyToHhvm::call(fs, targetReturnType, result, pos),
        pos,
      );
      !targetReturnType = tVoid;
    } else if (
      Hhvm.isHhvmShapeCopy(s, targetReturnType, pos) ||
      HhvmInterop.isTuple(s, targetReturnType)
    ) {
      SkipRuntime.HhvmArrayRetCreate::call(
        fs,
        args[0],
        HhvmInterop.CopyToHhvm::call(fs, targetReturnType, result, pos),
        pos,
      );
      !targetReturnType = tVoid;
    } else if (Hhvm.isMixedSubclass(fs, targetReturnType)) {
      SkipRuntime.HhvmVariantFromMixed::call(
        fs,
        args[0],
        HhvmInterop.InternalCreateRetValueFromMixed::call(fs, result, pos),
        pos,
      );
      !targetReturnType = tVoid;
    };

    // XXX why aren't we using the LowerGC pass?
    _ = fs.emitNamedCall{
      typ => tVoid,
      pos,
      name => "SKIP_Obstack_collect0",
      args => Array[gcNote],
      canThrow => true,
      allocAmount => AllocNothing(),
      mayRelocatePointers => true,
    };

    if (targetReturnType == tVoid) {
      kExistsVoidInstrTree
    } else {
      result
    }
  }

  static fun requestFunctions(
    s: mutable Specializer,
    call: GCallHhvmWrappedFunction,
    targs: Array<Tclass>,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
    pos: Pos,
  ): void {
    s.requestFunction(call.name, targs);
    for (t in call.targetParamTypes) {
      static::requestParameter(s, s.getTclass3(t, tparamEnv))
    };

    retType = s.getTclass3(call.targetReturnType, tparamEnv);
    if (Hhvm.isHhvmProxy(s, retType, pos) || Hhvm.isHhvmHandle(retType)) {
      if (Hhvm.isHhvmProxy(s, retType, pos)) {
        HhvmInterop.FetchProxyPointer::request(s, retType);
      };
      if (
        Hhvm.isHhvmArray(s, retType, pos) ||
        Hhvm.isHhvmShape(s, retType, pos)
      ) {
        SkipRuntime.HhvmArrayRetCreate::request(s)
      } else {
        SkipRuntime.HhvmObjectRetCreate::request(s)
      }
    } else if (Hhvm.isNullableType(s, retType)) {
      static::requestNullableExportReturn(s, retType);
    } else if (Hhvm.isOptionType(s, retType)) {
      static::requestOptionExportReturn(s, retType);
    } else if (Hhvm.isHhvmCopy(s, retType, s.pos)) {
      HhvmInterop.CopyToHhvm::request(s, retType);
      SkipRuntime.HhvmObjectRetCreate::request(s)
    } else if (
      Hhvm.isHhvmShapeCopy(s, retType, s.pos) ||
      HhvmInterop.isTuple(s, retType)
    ) {
      HhvmInterop.CopyToHhvm::request(s, retType);
      SkipRuntime.HhvmArrayRetCreate::request(s)
    } else if (Hhvm.isMixedSubclass(s, retType)) {
      HhvmInterop.InternalCreateRetValueFromMixed::request(s);
      SkipRuntime.HhvmVariantFromMixed::request(s);
    }
  }

  private static fun convertNullableExportReturn(
    fs: mutable O.FunSpecializer,
    arg: MaybeExists<InstrTree>,
    value: MaybeExists<InstrTree>,
    targetReturnType: Type,
    pos: Pos,
  ): void {
    s = fs.specializer;

    pos.invariant(
      Hhvm.isNullableType(s, targetReturnType),
      "EmitCallHhvmWrappedFunction::convertNullableExportReturn(): invalid arg",
    );

    t = Hhvm.getNullableTarg(s, targetReturnType, pos);
    HhvmInterop.HhvmVariantFactoryFromNullable::call(fs, t, arg, value, pos);
  }

  private static fun requestNullableExportReturn(
    s: mutable Specializer,
    retType: Tclass,
  ): void {
    pos = s.pos;

    pos.invariant(
      Hhvm.isNullableType(s, retType),
      "EmitCallHhvmWrappedFunction::requestNullableExportReturn(): invalid arg",
    );

    targ = Hhvm.tcGetNullableTarg(s, retType, pos);
    HhvmInterop.HhvmVariantFactoryFromNullable::request(s, targ);
  }

  private static fun convertOptionExportReturn(
    fs: mutable O.FunSpecializer,
    variant: MaybeExists<InstrTree>,
    value: MaybeExists<InstrTree>,
    targetReturnType: Type,
    pos: Pos,
  ): void {
    s = fs.specializer;

    pos.invariant(
      Hhvm.isOptionType(fs, targetReturnType),
      "EmitCallHhvmWrappedFunction::convertOptionExportReturn(): invalid arg",
    );

    t = Hhvm.getOptionTarg(s, targetReturnType, pos);
    tup = HhvmInterop_PropertyGetHelper.InternalCreateRetValueFromOption::call(
      fs,
      t,
      value,
      pos,
    );
    SkipRuntime.HhvmVariantFromMixed::call(fs, variant, tup, pos);
  }

  private static fun requestOptionExportReturn(
    s: mutable Specializer,
    retType: Tclass,
  ): void {
    s.pos.invariant(
      Hhvm.isOptionType(s, retType),
      "EmitCallHhvmWrappedFunction::requestOptionExportReturn(): invalid arg",
    );

    t = Hhvm.tcGetOptionTarg(s, retType, s.pos);
    HhvmInterop_PropertyGetHelper.InternalCreateRetValueFromOption::request(
      s,
      t,
    );
    SkipRuntime.HhvmVariantFromMixed::request(s);
  }

  private static fun lookupClassIdByType(
    fs: mutable O.FunSpecializer,
    t: Type,
    pos: Pos,
  ): HhvmTypeTable.Class {
    sc = fs.specializer.exampleSClass(t);
    gclassName = sc.gclassName;
    fs.specializer.hhvmTypeTable.getClass(gclassName, pos)
  }

  private static fun convertParameter(
    fs: mutable O.FunSpecializer,
    arg: MaybeExists<InstrTree>,
    t: Type,
    pos: Pos,
  ): (MaybeExists<InstrTree>, Svmi.ParamType) {
    s = fs.specializer;

    svmiCode = Svmi.ParamType::fromType(fs, t, false, pos);

    resultArg = (
      if (Hhvm.isNullableType(s, t)) {
        static::convertNullableParameter(fs, arg, t, pos, svmiCode)
      } else if (Hhvm.isOptionType(fs, t)) {
        static::convertOptionParameter(fs, arg, t, pos)
      } else if (t == tString) {
        SkipRuntime.StringExtractData::call(fs, arg, pos)
      } else if (Hhvm.isHhvmCopy(s, t, pos)) {
        classId = static::lookupClassIdByType(fs, t, pos);
        HhvmInterop_Gather.Gather::call(
          fs,
          t,
          arg,
          F.constantInt{fs, value => classId.globalIndex},
          pos,
        );
        //        HhvmInterop.CopyFromHhvm::call(
        //          fs,
        //          t,
        //          SkipRuntime.WrapHhvmObject::call(fs, arg, pos),
        //          pos,
        //        );
      } else if (
        Hhvm.isHhvmShapeCopy(s, t, pos) ||
        HhvmInterop.isTuple(fs, t)
      ) {
        HhvmInterop.CopyFromHhvm::call(
          fs,
          t,
          SkipRuntime.WrapHhvmArray::call(fs, arg, pos),
          pos,
        );
      } else if (Hhvm.isHhvmImport(s, t, pos)) {
        HhvmInterop.CreateFromProxyPointer::call(
          fs,
          t,
          SkipRuntime.WrapHhvmObject::call(fs, arg, pos),
          pos,
        )
      } else if (Hhvm.isHhvmArray(s, t, pos) || Hhvm.isHhvmShape(s, t, pos)) {
        HhvmInterop.CreateFromProxyPointer::call(
          fs,
          t,
          SkipRuntime.WrapHhvmArray::call(fs, arg, pos),
          pos,
        )
      } else if (Hhvm.isMixedSubclass(fs, t)) {
        HhvmInterop_PropertyGetHelper.InternalCreateMixedFromRetValue::call(
          fs,
          SkipRuntime.HhvmVariantToRetValue::call(fs, arg, pos),
          t,
          pos,
        )
      } else {
        arg
      }
    );

    (resultArg, svmiCode)
  }

  private static fun requestParameter(s: mutable Specializer, t: Tclass): void {
    if (t == tString) {
      SkipRuntime.StringExtractData::request(s);
    } else if (Hhvm.isNullableType(s, t)) {
      static::requestNullableParameter(s, t)
    } else if (Hhvm.isOptionType(s, t)) {
      static::requestOptionParameter(s, t)
    } else if (Hhvm.isHhvmImport(s, t, s.pos)) {
      SkipRuntime.WrapHhvmObject::request(s);
      HhvmInterop.CreateFromProxyPointer::request(s, t);
    } else if (Hhvm.isHhvmArray(s, t, s.pos) || Hhvm.isHhvmShape(s, t, s.pos)) {
      SkipRuntime.WrapHhvmArray::request(s);
      HhvmInterop.CreateFromProxyPointer::request(s, t);
    } else if (Hhvm.isHhvmCopy(s, t, s.pos)) {
      //      SkipRuntime.WrapHhvmObject::request(s);
      //      HhvmInterop.CopyFromHhvm::request(s, gt);
      HhvmInterop_Gather.Gather::request(s, t)
    } else if (Hhvm.isHhvmShapeCopy(s, t, s.pos) || HhvmInterop.isTuple(s, t)) {
      SkipRuntime.WrapHhvmArray::request(s);
      HhvmInterop.CopyFromHhvm::request(s, t);
    } else if (Hhvm.isMixedSubclass(s, t)) {
      SkipRuntime.HhvmVariantToRetValue::request(s);
      HhvmInterop_PropertyGetHelper.InternalCreateMixedFromRetValue::request(s);
    }
  }

  private static fun convertNullableParameter(
    fs: mutable O.FunSpecializer,
    arg: MaybeExists<InstrTree>,
    paramType: Type,
    pos: Pos,
    svmiCode: Svmi.ParamType,
  ): MaybeExists<InstrTree> {
    s = fs.specializer;

    pos.invariant(
      Hhvm.isNullableType(s, paramType),
      "EmitCallHhvmWrappedFunction::convertNullableParameter(): invalid arg",
    );

    // This is an object which we have to query for null or the boxed
    // value.

    converter = svmiCode match {
    | Svmi.ParamTypeVoid _
    | Svmi.ParamTypeBool _
    | Svmi.ParamTypeInt64 _
    | Svmi.ParamTypeFloat64 _
    | Svmi.ParamTypeString _
    | Svmi.ParamTypeHhvmObject _
    | Svmi.ParamTypeHhvmArray _
    | Svmi.ParamTypeMixed _ ->
      pos.die("bad case")
    | Svmi.ParamTypeNullableBool _ -> "SKIP_HHVM_Nullable_getBool"
    | Svmi.ParamTypeNullableInt64 _ -> "SKIP_HHVM_Nullable_getInt64"
    | Svmi.ParamTypeNullableFloat64 _ -> "SKIP_HHVM_Nullable_getFloat64"
    | Svmi.ParamTypeNullableString _ -> "SKIP_HHVM_Nullable_getString"
    | Svmi.ParamTypeNullableHhvmObject _ -> "SKIP_HHVM_Nullable_getObject"
    | Svmi.ParamTypeNullableHhvmArray _ -> "SKIP_HHVM_Nullable_getArray"
    };

    nullableResult = F.emitNamedCall{
      fs,
      typ => Hhvm.getSkipRetValueType(fs),
      pos,
      name => converter,
      args => Array[arg],
      llvmRetType => "{i64, i64} (i8*)",
    };

    t = Hhvm.getNullableTarg(s, paramType, pos);
    HhvmInterop_PropertyGetHelper.InternalCreateNullableFromRetValue::call(
      fs,
      t,
      nullableResult,
      pos,
    )
  }

  private static fun convertOptionParameter(
    fs: mutable O.FunSpecializer,
    arg: MaybeExists<InstrTree>,
    paramType: Type,
    pos: Pos,
  ): MaybeExists<InstrTree> {
    s = fs.specializer;

    pos.invariant(
      Hhvm.isOptionType(fs, paramType),
      "EmitCallHhvmWrappedFunction::convertOptionParameter(): invalid arg",
    );

    // This is an object which we have to query for null or the boxed
    // value.

    result = F.emitNamedCall{
      fs,
      typ => Hhvm.getSkipRetValueType(fs),
      pos,
      name => "SKIP_HHVM_Nullable_getMixed",
      args => Array[arg],
      llvmRetType => "{i64, i64} (i8*)",
    };

    t = Hhvm.getOptionTarg(s, paramType, pos);
    HhvmInterop_PropertyGetHelper.InternalCreateOptionFromRetValue::call(
      fs,
      t,
      result,
      pos,
    )
  }

  private static fun requestNullableParameter(
    s: mutable Specializer,
    arg: Tclass,
  ): void {
    s.pos.invariant(
      Hhvm.isNullableType(s, arg),
      "EmitCallHhvmWrappedFunction::requestNullableParameter(): invalid arg",
    );
    t = Hhvm.tcGetNullableTarg(s, arg, s.pos);
    HhvmInterop_PropertyGetHelper.InternalCreateNullableFromRetValue::request(
      s,
      t,
    );
  }

  private static fun requestOptionParameter(
    s: mutable Specializer,
    arg: Tclass,
  ): void {
    s.pos.invariant(
      Hhvm.isOptionType(s, arg),
      "EmitCallHhvmWrappedFunction::requestOptionParameter(): invalid arg",
    );
    t = Hhvm.tcGetOptionTarg(s, arg, s.pos);
    HhvmInterop_PropertyGetHelper.InternalCreateOptionFromRetValue::request(
      s,
      t,
    );
  }
}

class HhvmExportLazyGFun{
  isStatic: Bool,
  hhvmName: String,
  target: LazyGFun,
  targetParamTypes: Array<GType>,
  targetReturnType: GType,
} extends ConcreteLazyGFun {
  protected fun emitBody(emitter: mutable OuterIstEmitter): void {
    pos = emitter.funInfo.pos;

    emitter.emitBindParameters();

    args = mutable Vector[];
    for (pi in this.params.mapWithIndex((i, p) -> (p, i)).sortedBy(a ~>
      a.i0.index
    )) {
      p = pi.i0;
      if (p.index >= 0) {
        args.push(emitter.getLocal(p.name, p.pos));
      };
    };

    call = emitter.emitInstr(
      GCallHhvmWrappedFunction{
        typ => emitter.funInfo.funType.returnType,
        name => this.target,
        pos,
        args => args.toArray(),
        targetParamTypes => this.targetParamTypes,
        targetReturnType => this.targetReturnType,
      },
    );

    _ = emitter.emitInstr(GReturn{pos, value => call});
  }
}

class HhvmImportLazyGFun{
  isStatic: Bool,
  hhvmName: String,
} extends ConcreteLazyGFun {
  protected fun emitBody(emitter: mutable OuterIstEmitter): void {
    pos = emitter.funInfo.pos;

    emitter.emitBindParameters();

    object = emitter.funInfo.className match {
    | Some(className) ->
      if (!this.isStatic) {
        // Can only @hhvm_import a method within an @hhvm_import class.
        cd = emitter.converter.program.class_defs.getOrCrash(className.id);
        classIsImport = Hhvm.isImportAnnotation(cd.annotations, pos);
        pos.lazyInvariant(classIsImport, () ->
          `@hhvm_import methods can only be defined as static or on @hhvm_import classes`
        );

        p = this.params[0];
        Some(emitter.getLocal(p.name, pos))
      } else {
        None()
      }
    | None() -> None()
    };

    args = mutable Vector[];
    for (pi in this.params.mapWithIndex((i, p) -> (p, i)).sortedBy(a ~>
      a.i0.index
    )) {
      p = pi.i0;
      if (p.index >= 0) {
        args.push(emitter.getLocal(p.name, pos));
      };
    };

    call = emitter.emitInstr(
      GCallHhvmFunction{
        typ => emitter.funInfo.funType.returnType,
        pos,
        hhvmName => this.hhvmName,
        args => args.toArray(),
        object,
      },
    );

    _ = emitter.emitInstr(GReturn{pos, value => call});

    // Mark an @hhvm_import function as @debug so it won't be CSE'd (there
    // really should be a better way to do this).
    emitter.!funInfo = emitter.funInfo with {
      annotations => emitter.funInfo.annotations.add("@debug"),
    }
  }
}

fun exportHhvmFunctionWrapper(
  converter: Converter,
  hhvmName: String,
  funDef: I.FunDef,
): LazyGFun {
  target = O.FrontEndLazyGFun{frontEndName => funDef.getName()};
  funInfo = converter.getGFunction(target).funInfo;

  funType = funInfo.funType;
  tparams = funInfo.tparams;
  pos = funInfo.pos;

  (flatParams, numOptional, useOptionalMask) = flattenParams(
    funDef.params,
    O.paramTypes(funDef.params),
  );

  params = insertOptionalFlags(flatParams, numOptional, useOptionalMask, pos);
  wrapParams = params;
  exportStyle = HhvmExport{stringReturn => false, name => hhvmName};

  convertType = p -> {
    if (p == gtBool || p == gtFloat || p == gtInt) {
      p
    } else {
      gtNonGCPointer
    }
  };

  // Need to remap String and Object parameter and return types.  We'll evaluate
  // the target types later in the specializer (when we know more type
  // information) to determine how to do the conversion.
  wrapFunTypeParams = funType.params.map(convertType);
  wrapFunTypeReturn = convertType(funType.returnType);

  if (funType.returnType == gtVoid) {
    !wrapFunTypeReturn = gtVoid;
  } else if (
    funType.returnType == gtBool ||
    funType.returnType == gtInt ||
    funType.returnType == gtFloat
  ) {
    // No special handling needed for bool, int or float
    void
  } else {
    // For an @hhvm_export wrapper which returns a:
    //  string - we need to fake a stringref as the first parameter.
    //  nullable - we need to fake a variant* as the first parameter.
    //  object - we need to fake a Object* as the first parameter.
    !wrapFunTypeParams = Array[gtNonGCPointer].concat(wrapFunTypeParams);
    !wrapFunTypeReturn = gtVoid;
    !wrapParams = Array[
      ParameterInfo{
        name => "pseudo.return",
        value => None(),
        info => SkipOuterIstUtils.const_binding_info,
        index => 0,
        pos,
      },
    ].concat(
      wrapParams.map(p ->
        p with {index => p.index + (if (p.index >= 0) 1 else 0)}
      ),
    );
    !exportStyle = exportStyle with {stringReturn => true};
  };

  HhvmExportLazyGFun{
    // Mark the @hhvm_export wrapper as @debug so it won't be CSE'd (there
    // really should be a better way to do this).
    funInfo => GFunInfo{
      gfunction => GFunctionName(hhvmName + ".hhvm.wrapper"),
      pos,
      tparams,
      isNative => false,
      isMemoized => false,
      exportStyle,
      annotations => SSet["@debug", "@no_gc", "@no_inline"],
      className => None(),
      funType => funType with {
        params => wrapFunTypeParams,
        returnType => wrapFunTypeReturn,
      },
    },
    params => wrapParams,
    useOptionalMask,
    isStatic => false,
    hhvmName,
    target,
    targetParamTypes => funType.params,
    targetReturnType => funType.returnType,
  }
}

module end;
// -----------------------------------------------------------------------------
module HhvmInterop;

private fun isArray(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["Array"])
}

private fun isVector(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["Vector"])
}

fun isArraylike(env: readonly ClassLookupEnv, t: Type): Bool {
  isArray(env, t) || isVector(env, t);
}

private fun isMap(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["Map"])
}

private fun isUnorderedMap(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["UnorderedMap"])
}

fun isMaplike(env: readonly ClassLookupEnv, t: Type): Bool {
  isMap(env, t) || isUnorderedMap(env, t)
}

private fun isSet(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["Set"])
}

private fun isUnorderedSet(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["UnorderedSet"])
}

fun isSetlike(env: readonly ClassLookupEnv, t: Type): Bool {
  isSet(env, t) || isUnorderedSet(env, t)
}

fun isTuple(env: readonly ClassLookupEnv, t: Type): Bool {
  t.forEachTclass(tc -> tc.sclass(env).gclassName.id.startsWith("Tuple"))
}

fun tupleGetSize(s: readonly O.Specializer, t: Type): Int {
  s.sclasses[t.exampleSClass(s).id].unscalarizedFields.size()
}

fun tcTupleGetType(s: readonly O.Specializer, tc: Tclass, idx: Int): Tclass {
  s.sclasses[tc.sclassID].unscalarizedFields[idx].typ
}

fun tupleGetType(s: readonly O.Specializer, t: Type, idx: Int): Type {
  t match {
  | tc @ Tclass _ -> tcGetTarg(s, tc, idx, s.pos)
  | spos @ Tsuperposition _ ->
    smap = spos.smap.smap
      .keys()
      .map(sid -> {
        (sid, tcGetTarg(s, spos.typeInSuperposition(sid), idx, s.pos))
      })
      .collect(UnorderedMap);
    Type::make(smap)
  }
}

private fun tcGetTarg(
  s: readonly O.Specializer,
  tc: Tclass,
  index: Int,
  pos: Pos,
): Tclass {
  s.getTargs(tc).maybeGet(index) match {
  | Some(targ) -> targ
  | None() -> pos.die(`No such targ with index ${index} for ${tc}`)
  }
}

private fun getTarg(
  s: readonly O.Specializer,
  t: Type,
  index: Int,
  pos: Pos,
): Type {
  t match {
  | tc @ Tclass _ -> tcGetTarg(s, tc, index, pos)
  | ts @ Tsuperposition _ ->
    // Create a superposition of the various targs.
    smap = UnorderedMap::mcreate(ts.smap.smap.size());
    for (k => v in ts.smap.smap) smap.add(k, tcGetTarg(s, v, index, pos));
    Type::make(freeze(smap))
  }
}

base class InternalCreateFrom extends O.GCustomIntrinsic {
  deferred const methodName: String;

  protected fun emitBody(e: mutable O.OuterIstEmitter): void {
    pos = this.funInfo.pos;

    targT = e.funInfo.tparams[0];
    targI = e.funInfo.tparams[1];

    e.emitBindParameters();
    items = e.params[0];

    concrete = e.emitInstr(
      O.GObject{
        typ => O.GTapply(
          FrontEndLazyGClass("Concrete"),
          DeepFrozen(),
          Array[targT],
        ),
        args => Array[],
        pos,
      },
    );

    obj = e.emitInstr(
      O.GCallMethod{
        typ => targT,
        source => FrontEndLazyGClass(
          `<no source for InternalCreateFrom:${static::methodName}>`,
        ),
        method => static::methodName,
        targs => Array[targI],
        args => Array[concrete, items],
        pos,
      },
    );

    e.emitReturn(obj, pos);
  }
}

base class InternalCreateFromIterator() {
  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    i: Type,
    items: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    if (t.isMutable()) {
      InternalCreateMutableFromIterator::call(fs, t, i, items, pos)
    } else {
      InternalCreateFrozenFromIterator::call(fs, t, i, items, pos)
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass, i: Tclass): void {
    if (t.mutability is Mutable()) {
      InternalCreateMutableFromIterator::request(s, t, i)
    } else {
      InternalCreateFrozenFromIterator::request(s, t, i)
    }
  }
}

base class InternalCreateFromItems() {
  static fun call(
    fs: mutable O.FunSpecializer,
    t: Type,
    i: Type,
    items: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    if (t.isMutable()) {
      InternalCreateMutableFromItems::call(fs, t, i, items, pos)
    } else {
      InternalCreateFrozenFromItems::call(fs, t, i, items, pos)
    }
  }

  static fun request(s: mutable O.Specializer, t: Tclass, i: Tclass): void {
    if (t.mutability is Mutable()) {
      InternalCreateMutableFromItems::request(s, t, i)
    } else {
      InternalCreateFrozenFromItems::request(s, t, i)
    }
  }
}

// fun internalCreateFrozenFromIterator<T, I>(items: I): T;
extension class InternalCreateFrozenFromIterator extends InternalCreateFrom {
  const methodName: String = "createFromIterator";
}

extension class InternalCreateMutableFromIterator extends InternalCreateFrom {
  const methodName: String = "mcreateFromIterator";
}

// fun internalCreateFromItems<T, I>(items: I): T;
extension class InternalCreateFrozenFromItems extends InternalCreateFrom {
  const methodName: String = "createFromItems";
}

extension class InternalCreateMutableFromItems extends InternalCreateFrom {
  const methodName: String = "mcreateFromItems";
}

// Intrinsic for:
//   fun internalBitcastToRetValue<T>(i: T): (Int, Int);
//
extension class InternalBitcastToRetValue extends O.CustomIntrinsic {
  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    pos = this.funInfo.pos;
    s = fs.specializer;

    value = fs.getValue(gInstr.args[0]);

    targT = fs.specializeType(this.funInfo.tparams[0]);

    if (Hhvm.isOptionType(fs, targT)) {
      subarg = Hhvm.getOptionTarg(s, targT, pos);
      if (Hhvm.isOptionType(fs, subarg)) {
        return HhvmInterop_PropertyGetHelper.InternalCreateRetValueFromOptionOption::call(
          fs,
          Hhvm.getOptionTarg(s, subarg, pos),
          value,
          pos,
        );
      } else {
        return HhvmInterop_PropertyGetHelper.InternalCreateRetValueFromOption::call(
          fs,
          subarg,
          value,
          pos,
        );
      }
    };

    if (
      isArraylike(fs, targT) ||
      isMaplike(fs, targT) ||
      isTuple(fs, targT) ||
      isSetlike(fs, targT)
    ) {
      !value = CopyToHhvm::call(fs, targT, value, pos);
      // Really an array - but tHhvmShapeHandle is mis-named
      !targT = tHhvmShapeHandle;
    };

    if (Hhvm.isMixedSubclass(fs, targT)) {
      return InternalCreateRetValueFromMixed::call(fs, value, pos);
    };

    if (Hhvm.isHHLambdaSubclass(fs, targT)) {
      return InternalBitcastLambdaToRetValue::call(fs, value, pos);
    };

    result = (
      if (targT == tBool) {
        F.emitZeroExtend{fs, typ => tInt, value, pos}
      } else if (targT == tInt) {
        value
      } else if (
        (targT == tFloat) ||
        (targT == tString) ||
        Hhvm.isHhvmHandle(targT) ||
        Hhvm.isHhvmShapeHandle(targT)
      ) {
        F.emitReinterpret{fs, typ => tInt, value, pos}
      } else if (Hhvm.isHhvmProxy(s, targT, pos)) {
        handle = FetchProxyPointer::call(fs, targT, value, pos);
        F.emitReinterpret{fs, typ => tInt, value => handle, pos};
      } else if (
        Hhvm.isHhvmCopy(s, targT, pos) ||
        Hhvm.isHhvmShapeCopy(s, targT, pos)
      ) {
        F.emitReinterpret{
          fs,
          typ => tInt,
          value => CopyToHhvm::call(fs, targT, value, pos),
          pos,
        }
      } else {
        pos.die(
          `internalBitcastToRetValue: Unable to cast from ${targT} to RetValue`,
        );
      }
    );

    resultType = F.constantInt{
      fs,
      value => Svmi.ParamType::fromType(fs, targT, false, pos).code(),
    };

    F.emitObject{
      fs,
      args => Array[result, resultType],
      pos,
      typ => Hhvm.getSkipRetValueType(fs),
    }
  }

  protected fun requestFunctions(
    s: mutable O.Specializer,
    targs: Array<Tclass>,
    _tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    pos = this.funInfo.pos;
    targT = targs[0];

    if (Hhvm.isOptionType(s, targT)) {
      subarg = Hhvm.tcGetOptionTarg(s, targT, pos);
      if (Hhvm.isOptionType(s, subarg)) {
        return HhvmInterop_PropertyGetHelper.InternalCreateRetValueFromOptionOption::request(
          s,
          Hhvm.tcGetOptionTarg(s, subarg, pos),
        );
      } else {
        return HhvmInterop_PropertyGetHelper.InternalCreateRetValueFromOption::request(
          s,
          subarg,
        );
      }
    };

    if (
      isArraylike(s, targT) ||
      isMaplike(s, targT) ||
      isTuple(s, targT) ||
      isSetlike(s, targT)
    ) {
      return CopyToHhvm::request(s, targT);
    };

    if (Hhvm.isHHLambdaSubclass(s, targT)) {
      return InternalBitcastLambdaToRetValue::request(s);
    };

    if (Hhvm.isMixedSubclass(s, targT)) {
      InternalCreateRetValueFromMixed::request(s);
    } else if (Hhvm.isHhvmProxy(s, targT, pos)) {
      FetchProxyPointer::request(s, targT);
    } else if (
      Hhvm.isHhvmCopy(s, targT, pos) ||
      Hhvm.isHhvmShapeCopy(s, targT, pos)
    ) {
      CopyToHhvm::request(s, targT);
    }
  }
}

// Intrinsic for:
//   fun createFromProxyPointer<T>(handle: Runtime.HhvmHandle): T;
//
extension class CreateFromProxyPointer extends O.CustomIntrinsic {
  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    pos = this.funInfo.pos;
    s = fs.specializer;
    gtReturn = this.funInfo.tparams[0];
    tReturn = fs.specializeType(gtReturn).asTclass(pos);
    handle = fs.getValue(gInstr.args[0]);
    if (fs.specializer.sclasses[tReturn.sclassID].sclass.kind.isValueClass()) {
      // A value type - just cast it
      F.emitCast{fs, typ => tReturn, value => handle, pos}
    } else if (Hhvm.isHhvmImport(s, tReturn, pos)) {
      // Need to ask HHVM what the underlying type is and then call
      // createFromProxyPointerAndType<T>().
      hhvmType = SkipRuntime.GetObjectType::call(fs, handle, pos);
      CreateFromProxyPointerAndType::call(fs, tReturn, handle, hhvmType, pos);
    } else if (
      Hhvm.isHhvmArray(s, tReturn, pos) ||
      Hhvm.isHhvmShape(s, tReturn, pos)
    ) {
      // @hhvm_array and @hhvm_shape must be a final class so no need to query
      // the type - just construct the right object.
      F.emitObject{fs, typ => tReturn, pos, args => Array[handle]};
    } else {
      pos.die(`(1) Unable to construct non-@hhvm_import type ${tReturn}`);
    }
  }

  protected fun requestFunctions(
    s: mutable O.Specializer,
    targs: Array<Tclass>,
    _tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    retType = targs[0];
    if (Hhvm.isHhvmImport(s, retType, s.pos)) {
      CreateFromProxyPointerAndType::request(s, retType);
    }
  }
}

// Intrinsic for:
//   fun createFromProxyPointerAndType<T>(handle: Runtime.HhvmHandle,
//                                        hhvmType: String): T;
//
extension class CreateFromProxyPointerAndType extends O.CustomIntrinsic {
  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    pos = this.funInfo.pos;
    s = fs.specializer;

    gtReturn = this.funInfo.funType.returnType;
    gHandle = gInstr.args[0];
    gHhvmType = gInstr.args[1];
    tReturn = fs.specializeType(gtReturn).asTclass(pos);
    handle = fs.getValue(gHandle);

    pos.invariant(
      !Hhvm.isHhvmArray(s, tReturn, pos) && !Hhvm.isHhvmShape(s, tReturn, pos),
      "cannot call createFromProxyPointerAndType on @hhvm_array or @hhvm_shape object",
    );

    if (fs.specializer.sclasses[tReturn.sclassID].sclass.kind.isValueClass()) {
      // A value type - just cast it
      F.emitCast{fs, typ => tReturn, value => handle, pos}
    } else if (Hhvm.isHhvmImport(s, tReturn, pos)) {
      mut = tReturn.isMutable();

      hhvmTypeId = fs.getValue(gHhvmType);

      sclasses = {
        sclasses = mutable Vector[];
        _ = tReturn.forEachConcreteSubtype(fs, subclass -> {
          sclasses.push(Tclass(subclass.id, Mutability::fromFlag(mut)));
          true
        });
        sclasses.toArray()
      };

      known = mutable UnorderedMap[];
      cases = sclasses
        .map(t -> {
          name = Hhvm.importAnnotationName(
            t.sclass(fs).annotations,
            pos,
          ) match {
          | Some(name) ->
            if (!name.isEmpty()) name else t.sclass(fs).gclassName.id
          | None() -> pos.die(`${t} isn't marked as @hhvm_import`)
          };
          // Check for duplicate cases
          known.maybeGet(name) match {
          | Some(prev) ->
            pos.die(`Both ${prev} and ${t} correspond to HHVM name ${name}`)
          | None() -> known![name] = t
          };
          F.constantString{fs, value => name};
        })
        .collect(Array);

      successors = cases.map(_ -> BlockSuccessor(fs.newBlockID()));

      join = fs.newBlockID();
      default = fs.newBlockID();

      F.emitStringSwitch{
        fs,
        value => hhvmTypeId,
        cases,
        successors => Array[BlockSuccessor(default)].concat(successors),
        pos,
      };

      fs.startNewBlock(default);
      HhvmInterop.ThrowUnknownHhvmTypeError::call(
        fs,
        hhvmTypeId,
        F.constantString{fs, value => tReturn.toString()},
        pos,
      );
      _ = fs.emitUnreachable{pos, why => "throwUnknownHhvmTypeError"};

      for (i in successors.zip(sclasses)) {
        (succ, typ) = i;
        fs.startNewBlock(succ.target);
        obj = F.emitObject{fs, typ, pos, args => Array[handle]};
        F.emitJump{fs, target => join, args => Array[obj], pos};
      };

      blockParams = F.startNewBlock{
        fs,
        target => join,
        args => Array[tReturn],
        pos,
      };

      blockParams[0]
    } else {
      pos.die(`(0) Unable to construct non-@hhvm_import type ${tReturn}`);
    }
  }

  protected fun requestFunctions(
    s: mutable O.Specializer,
    _targs: Array<Tclass>,
    _tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    HhvmInterop.ThrowUnknownHhvmTypeError::request(s);
  }
}

// native fun copyFromHhvm<T>(handle: readonly Runtime.HhvmHandle): T;
extension class CopyFromHhvm extends O.CustomIntrinsic {
  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    // NOTE: If you try to copy a cyclic graph using this you're going to have a
    // bad day...

    s = fs.specializer;
    pos = this.funInfo.pos;

    targT = fs.specializeType(this.funInfo.tparams[0]);

    handleType = (tHhvmHandle : Type);
    handle = fs.getValue(gInstr.args[0]);

    if (isTuple(s, targT)) {
      return this.emitTuple(fs, targT, handle, pos)
    };

    if (isArraylike(s, targT)) {
      return this.emitCopyFromArray(fs, targT, handle, pos);
    };

    isShape = Hhvm.isHhvmShapeCopy(s, targT, pos);

    if (!isShape && !Hhvm.isHhvmCopy(s, targT, pos)) {
      pos.die(`Cannot copyFromHhvm() non-@hhvm_copy object type ${targT}`)
    };

    scinfo = s.sclasses[targT.asTclass(pos).sclassID];
    sc = scinfo.sclass;

    if (sc.kind is KBase()) {
      return this.hhvmCopyBase(fs, targT, handle, pos);
    };

    if (isShape) {
      !handleType = fs.specializeType(O.gtHhvmShapeHandle);
      !handle = F.emitReinterpret{fs, typ => handleType, value => handle, pos};
    };

    // The fields in the SClass are already flattened - but we need to work
    // off the original unflattened fields.
    args = scinfo.unscalarizedFields.map(field -> {
      // ensure that the field is reasonable to copy from...
      pos.lazyInvariant(Hhvm.isPortableType(s, field.typ, pos), () ->
        `Unable to copy ${sc}.${field.name}: ${field.typ} from HHVM`
      );
      (
        field.name,
        PropertyGetHelper::call(
          fs,
          handleType,
          field.typ,
          handle,
          F.constantString{fs, value => field.name},
          pos,
        ),
      )
    });

    sc.kind match {
    | KBase() -> pos.die("handled above")
    | KClass() ->
      F.emitObject{fs, args => args.map(i -> i.i1), pos, typ => targT}
    | KValue() ->
      existArgs = {
        tmp = mutable Vector[];
        for (arg_ in args) {
          arg_.i1 match {
          | O.NotExists(why) ->
            fs.emitUnreachable{pos, why};
            return O.NotExists(why)
          | O.Exists(arg) -> tmp.push((arg_.i0, arg))
          }
        };
        tmp.toArray()
      };

      O.Exists(O.InstrInner(existArgs))
    };
  }

  protected fun requestFunctions(
    s: mutable O.Specializer,
    targs: Array<Tclass>,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    pos = this.funInfo.pos;

    targT = targs[0];

    if (HhvmInterop.isTuple(s, targT)) {
      return this.requestTuple(s, tparamEnv);
    };

    if (isArraylike(s, targT)) {
      return this.requestCopyFromArray(s, targT, pos);
    };

    isShape = Hhvm.isHhvmShapeCopy(s, targT, pos);
    if (!isShape && !Hhvm.isHhvmCopy(s, targT, pos)) {
      pos.die(`Cannot copyFromHhvm() non-@hhvm_copy object type ${targT}`)
    };

    handleType = if (isShape) tHhvmShapeHandle else tHhvmHandle;

    info = s.sclasses[targT.sclassID];
    sclass = info.sclass;

    if (sclass.kind is KBase()) {
      this.requestHhvmCopyBase(s, targs, tparamEnv);
    } else {
      for (field in info.unscalarizedFields) {
        PropertyGetHelper::request(s, handleType, field.typ);
      }
    }
  }

  private fun hhvmCopyBase(
    fs: mutable O.FunSpecializer,
    tReturn: Type,
    handle: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    // For a base class ask HHVM for the actual concrete subclass and call
    // copyFromHhvm() with that as the actual targ.

    hhvmTypeId = SkipRuntime.GetObjectType::call(fs, handle, pos);

    mut = Mutability::fromFlag(tReturn.isMutable());

    tclasses = {
      tclasses = mutable Vector[];
      _ = tReturn.forEachConcreteSubtype(fs, subclass -> {
        tclasses.push(Tclass(subclass.id, mut));
        true
      });
      tclasses
    };

    known = mutable UnorderedMap[];
    cases = tclasses
      .map(t -> {
        name = Hhvm.copyAnnotationName(
          fs.getSClass(t.sclassID).annotations,
          pos,
        ) match {
        | Some(name) ->
          if (!name.isEmpty()) name else t.sclass(fs).gclassName.id
        | None() -> pos.die(`${t} isn't marked as @hhvm_copy`)
        };
        // Check for duplicate cases
        known.maybeGet(name) match {
        | Some(prev) ->
          pos.die(`Both ${prev} and ${t} correspond to HHVM name ${name}`)
        | None() -> known![name] = t
        };
        F.constantString{fs, value => name};
      })
      .collect(Array);

    successors = cases.map(_ -> BlockSuccessor(fs.newBlockID()));

    join = fs.newBlockID();
    default = fs.newBlockID();

    F.emitStringSwitch{
      fs,
      value => hhvmTypeId,
      cases,
      successors => Array[BlockSuccessor(default)].concat(successors),
      pos,
    };

    fs.startNewBlock(default);
    HhvmInterop.ThrowUnknownHhvmTypeError::call(
      fs,
      hhvmTypeId,
      F.constantString{fs, value => tReturn.toString()},
      pos,
    );
    _ = fs.emitUnreachable{pos, why => "throwUnknownHhvmTypeError"};

    for (i in successors.zip(tclasses)) {
      (succ, typ) = i;
      fs.startNewBlock(succ.target);
      obj = HhvmInterop.CopyFromHhvm::call(fs, typ, handle, pos);
      F.emitJump{fs, target => join, args => Array[obj], pos};
    };

    blockParams = F.startNewBlock{
      fs,
      target => join,
      args => Array[tReturn],
      pos,
    };

    blockParams[0]
  }

  private fun requestHhvmCopyBase(
    s: mutable O.Specializer,
    targs: Array<Tclass>,
    _tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    HhvmInterop.ThrowUnknownHhvmTypeError::request(s);

    retType = targs[0];

    sci = s.sclasses[retType.sclassID];
    for (subtypeId in sci.subtypes) {
      HhvmInterop.CopyFromHhvm::request(
        s,
        Tclass(subtypeId, retType.mutability),
      )
    };
  }

  fun emitCopyFromArray(
    fs: mutable O.FunSpecializer,
    targT: Type,
    handle: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;

    elementType = getTarg(s, targT, 0, pos);
    pos.lazyInvariant(Hhvm.isPortableType(s, elementType, pos), () ->
      `Unable to copy ${targT} value ${elementType} from HHVM`
    );

    arrayType = fs.specializer.specializeType2(
      FrontEndLazyGClass("Vector.HH_varray2"),
      DeepFrozen(),
      Array[elementType],
    );

    array = CreateFromProxyPointer::call(fs, arrayType, handle, pos);
    InternalCreateFromItems::call(fs, targT, arrayType, array, pos);
  }

  fun requestCopyFromArray(
    s: mutable O.Specializer,
    targT: Tclass,
    pos: Pos,
  ): void {
    elementType = tcGetTarg(s, targT, 0, pos);
    arrayType = s.getTclass2(
      FrontEndLazyGClass("Vector.HH_varray2"),
      Array[elementType],
      DeepFrozen(),
    );

    CreateFromProxyPointer::request(s, arrayType);
    InternalCreateFromItems::request(s, targT, arrayType);
  }

  fun emitTuple(
    fs: mutable O.FunSpecializer,
    retType: Type,
    value: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;

    tupleHelperType = fs.specializeType(
      O.GTapply(
        FrontEndLazyGClass("HhvmInterop.TupleHelper"),
        Readonly(),
        Array[],
      ),
    );
    obj = HhvmInterop.CreateFromProxyPointer::call(
      fs,
      tupleHelperType,
      value,
      pos,
    );

    args = Array::fillBy(HhvmInterop.tupleGetSize(s, retType), i -> {
      HhvmInterop_PropertyGetHelper.InternalCreateFromRetValue::call(
        fs,
        HhvmInterop.tupleGetType(s, retType, i),
        HhvmInterop.TupleHelperGet::call(
          fs,
          obj,
          F.constantInt{fs, value => i},
          pos,
        ),
        pos,
      );
    });

    F.emitObject{fs, typ => retType, args, pos}
  }

  fun requestTuple(
    s: mutable O.Specializer,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    retType = s.getTclass3(this.funInfo.funType.returnType, tparamEnv);

    tupleHelperType = s.getTclass2(
      FrontEndLazyGClass("HhvmInterop.TupleHelper"),
      Array[],
      Readonly(),
    );
    HhvmInterop.CreateFromProxyPointer::request(s, tupleHelperType);
    HhvmInterop.TupleHelperGet::request(s);
    for (i in Range(0, HhvmInterop.tupleGetSize(s, retType))) {
      HhvmInterop_PropertyGetHelper.InternalCreateFromRetValue::request(
        s,
        HhvmInterop.tcTupleGetType(s, retType, i),
      );
    };
  }
}

// native fun copyToHhvm<T>(o: T): readonly Runtime.HhvmHandle;
extension class CopyToHhvm extends O.CustomIntrinsic {
  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;
    pos = this.funInfo.pos;

    targT = fs.specializeType(this.funInfo.tparams[0]);
    obj = fs.getValue(gInstr.args[0]);

    if (isArraylike(s, targT)) {
      return this.emitCopyToArray(fs, targT, obj, pos);
    };

    if (isMaplike(fs, targT)) {
      return this.emitCopyToMap(fs, targT, obj, pos);
    };

    if (isSetlike(fs, targT)) {
      return this.emitCopyToSet(fs, targT, obj, pos);
    };

    if (isTuple(s, targT)) {
      return this.emitCopyToTuple(fs, targT, obj, pos);
    };

    isShape = Hhvm.isHhvmShapeCopy(s, targT, pos);
    if (!isShape && !Hhvm.isHhvmCopy(s, targT, pos)) {
      pos.die(`Cannot copyToHhvm() non-@hhvm_copy object type ${targT}`)
    };

    scinfo = s.sclasses[targT.asTclass(pos).sclassID];
    sc = scinfo.sclass;

    if (sc.kind is KBase()) {
      return this.hhvmCopyBase(fs, targT, obj, pos);
    };

    if (isShape) {
      this.emitCopyToShape(fs, scinfo.gclass, obj, pos);
    } else {
      this.emitCopyToObject(fs, scinfo.gclass, obj, pos);
    }
  }

  protected fun requestFunctions(
    s: mutable O.Specializer,
    targs: Array<Tclass>,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    pos = this.funInfo.pos;

    targT = targs[0];

    if (isArraylike(s, targT)) {
      this.requestCopyToArray(s, targT, pos);
      return void;
    };

    if (isMaplike(s, targT)) {
      this.requestCopyToMap(s, targT, pos);
      return void;
    };

    if (isSetlike(s, targT)) {
      this.requestCopyToSet(s, targT, pos);
      return void;
    };

    if (isTuple(s, targT)) {
      this.requestCopyToTuple(s, targT);
      return void;
    };

    isShape = Hhvm.isHhvmShapeCopy(s, targT, pos);
    if (!isShape && !Hhvm.isHhvmCopy(s, targT, pos)) {
      pos.die(`Cannot copyToHhvm() non-@hhvm_copy object type ${targT}`)
    };

    info = s.sclasses[targT.sclassID];
    if (info.sclass.kind is KBase()) {
      this.requestHhvmCopyBase(s, targs, tparamEnv);
      return void;
    };

    if (isShape) {
      this.requestCopyToShape(s, targT, pos, tparamEnv);
    } else {
      this.requestCopyToObject(s, targT, pos, tparamEnv);
    };
  }

  fun emitCopyToArray(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;

    elementType = getTarg(s, targT, 0, pos);
    pos.lazyInvariant(Hhvm.isPortableType(s, elementType, pos), () ->
      `Unable to copy ${targT} value ${elementType} to HHVM`
    );

    arrayType = s.specializeType2(
      FrontEndLazyGClass("Vector.HH_varray2"),
      DeepFrozen(),
      Array[elementType],
    );

    // NOTE: Can't use InternalCreateFrozenFromIterator because
    // Vector::createFromItems() expects different Targs than
    // HH_varray2::createFromItems().  Fixes that has some kind of compiler
    // error.
    array = InternalCreateVarrayFromItems::call(
      fs,
      elementType,
      targT,
      obj,
      pos,
    );

    FetchProxyPointer::call(fs, arrayType, array, pos);
  }

  fun requestCopyToArray(
    s: mutable O.Specializer,
    targT: Tclass,
    pos: Pos,
  ): void {
    elementType = tcGetTarg(s, targT, 0, pos);
    arrayType = s.getTclass2(
      FrontEndLazyGClass("Vector.HH_varray2"),
      Array[elementType],
      DeepFrozen(),
    );

    InternalCreateVarrayFromItems::request(s, elementType, targT);

    FetchProxyPointer::request(s, arrayType);
  }

  fun emitCopyToMap(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;

    keyType = getTarg(s, targT, 0, pos);
    valueType = getTarg(s, targT, 1, pos);
    mapType = s.specializeType2(
      FrontEndLazyGClass("Map.HH_darray2"),
      DeepFrozen(),
      Array[keyType, valueType],
    );

    tup = s.specializeType2(
      FrontEndLazyGClass("Tuple2"),
      DeepFrozen(),
      Array[keyType, valueType],
    );

    itemsType = s.specializeType2(
      FrontEndLazyGClass("Iterator"),
      Mutable(),
      Array[tup],
    );
    items = HhvmInterop.InternalMapGetItems::call(
      fs,
      keyType,
      valueType,
      obj,
      pos,
    );

    map = InternalCreateFromIterator::call(fs, mapType, itemsType, items, pos);

    FetchProxyPointer::call(fs, mapType, map, pos);
  }

  fun requestCopyToMap(
    s: mutable O.Specializer,
    targT: Tclass,
    pos: Pos,
  ): void {
    keyType = tcGetTarg(s, targT, 0, pos);
    pos.lazyInvariant(Hhvm.isPortableType(s, keyType, pos), () ->
      `Unable to copy ${targT} key ${keyType} to HHVM`
    );

    valueType = tcGetTarg(s, targT, 1, pos);
    pos.lazyInvariant(Hhvm.isPortableType(s, valueType, pos), () ->
      `Unable to copy ${targT} value ${valueType} to HHVM`
    );

    mapType = s.getTclass2(
      FrontEndLazyGClass("Map.HH_darray2"),
      Array[keyType, valueType],
      DeepFrozen(),
    );

    tup = s.getTclass2(
      FrontEndLazyGClass("Tuple2"),
      Array[keyType, valueType],
      DeepFrozen(),
    );

    itemsType = s.getTclass2(
      FrontEndLazyGClass("Iterator"),
      Array[tup],
      Mutable(),
    );

    HhvmInterop.InternalMapGetItems::request(s, keyType, valueType);

    InternalCreateFromIterator::request(s, mapType, itemsType);
    FetchProxyPointer::request(s, mapType);
  }

  fun emitCopyToSet(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;

    keyType = getTarg(s, targT, 0, pos);
    setType = s.specializeType2(
      FrontEndLazyGClass("Set.HH_keyset2"),
      DeepFrozen(),
      Array[keyType],
    );

    itemsType = s.specializeType2(
      FrontEndLazyGClass("Iterator"),
      Mutable(),
      Array[keyType],
    );
    items = HhvmInterop.InternalSetGetValues::call(fs, keyType, obj, pos);

    set = InternalCreateFromIterator::call(fs, setType, itemsType, items, pos);
    FetchProxyPointer::call(fs, setType, set, pos);
  }

  fun requestCopyToSet(
    s: mutable O.Specializer,
    targT: Tclass,
    pos: Pos,
  ): void {
    keyType = tcGetTarg(s, targT, 0, pos);
    pos.lazyInvariant(Hhvm.isPortableType(s, keyType, pos), () ->
      `Unable to copy ${targT} key ${keyType} to HHVM`
    );

    setType = s.getTclass2(
      FrontEndLazyGClass("Set.HH_keyset2"),
      Array[keyType],
      DeepFrozen(),
    );

    itemsType = s.getTclass2(
      FrontEndLazyGClass("Iterator"),
      Array[keyType],
      Mutable(),
    );

    HhvmInterop.InternalSetGetValues::request(s, keyType);

    InternalCreateFromIterator::request(s, setType, itemsType);
    FetchProxyPointer::request(s, setType);
  }

  fun emitCopyToShape(
    fs: mutable O.FunSpecializer,
    gc: O.GClass,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    shapeEntry = fs.specializer.hhvmTypeTable.getClass(gc.name, pos);
    shapeId = shapeEntry.globalIndex;

    handle = HhvmInterop_ShapeCons.Create::call(
      fs,
      F.constantInt{fs, value => shapeId},
      pos,
    );

    for (field in shapeEntry.fields) {
      typ = fs.specializeType(field.skipType);
      value = F.emitGetField{fs, obj, field => field.skipName, typ, pos};
      HhvmInterop_ShapeCons.SetFieldMixed::call(
        fs,
        handle,
        F.constantInt{fs, value => field.globalIndex},
        HhvmInterop.InternalBitcastToRetValue::call(fs, typ, value, pos),
        pos,
      );
    };

    HhvmInterop_ShapeCons.Finish::call(fs, handle, pos);

    F.emitReinterpret{fs, typ => tHhvmHandle, value => handle, pos}
  }

  fun requestCopyToShape(
    s: mutable O.Specializer,
    targT: Tclass,
    pos: Pos,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    gclassName = s.exampleSClass(targT).gclassName;
    shapeEntry = s.hhvmTypeTable.getClass(gclassName, pos);

    HhvmInterop_ShapeCons.Create::request(s);

    for (field in shapeEntry.fields) {
      tc = s.getTclass3(field.skipType, tparamEnv);
      HhvmInterop.InternalBitcastToRetValue::request(s, tc);
      HhvmInterop_ShapeCons.SetFieldMixed::request(s);
    };

    HhvmInterop_ShapeCons.Finish::request(s);
  }

  fun emitCopyToObject(
    fs: mutable O.FunSpecializer,
    gc: O.GClass,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;

    classEntry = s.hhvmTypeTable.getClass(gc.name, pos);
    classId = classEntry.globalIndex;

    handle = HhvmInterop_ObjectCons.Create::call(
      fs,
      F.constantInt{fs, value => classId},
      pos,
    );

    for (field in classEntry.fields) {
      typ = fs.specializeType(field.skipType);
      value = F.emitGetField{fs, obj, field => field.skipName, typ, pos};
      HhvmInterop_ObjectCons.SetFieldMixed::call(
        fs,
        handle,
        F.constantInt{fs, value => field.globalIndex},
        HhvmInterop.InternalBitcastToRetValue::call(fs, typ, value, pos),
        pos,
      );
    };

    HhvmInterop_ObjectCons.Finish::call(fs, handle, pos);

    handle
  }

  fun requestCopyToObject(
    s: mutable O.Specializer,
    targT: Tclass,
    pos: Pos,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    gclassName = s.exampleSClass(targT).gclassName;
    classEntry = s.hhvmTypeTable.getClass(gclassName, pos);

    HhvmInterop_ObjectCons.Create::request(s);

    for (field in classEntry.fields) {
      tc = s.getTclass3(field.skipType, tparamEnv);
      HhvmInterop.InternalBitcastToRetValue::request(s, tc);
      HhvmInterop_ObjectCons.SetFieldMixed::request(s);
    };

    HhvmInterop_ObjectCons.Finish::request(s);
  }

  fun emitCopyToTuple(
    fs: mutable O.FunSpecializer,
    targT: Type,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    s = fs.specializer;

    tupleHelperType = fs.specializeType(
      O.GTapply(
        FrontEndLazyGClass("HhvmInterop.TupleHelper"),
        Mutable(),
        Array[],
      ),
    );
    tupleHelper = TupleHelperCreate::call(fs, pos);
    for (i in Range(0, tupleGetSize(s, targT))) {
      iType = tupleGetType(s, targT, i);
      field = F.emitGetField{fs, obj, field => `i${i}`, typ => iType, pos};
      value = InternalBitcastToRetValue::call(fs, iType, field, pos);
      TupleHelperAppend::call(fs, tupleHelper, value, pos);
    };
    FetchProxyPointer::call(fs, tupleHelperType, tupleHelper, pos)
  }

  fun requestCopyToTuple(s: mutable O.Specializer, targT: Tclass): void {
    tupleHelperType = s.getTclass2(
      FrontEndLazyGClass("HhvmInterop.TupleHelper"),
      Array[],
      Mutable(),
    );
    TupleHelperCreate::request(s);
    TupleHelperAppend::request(s);
    for (i in Range(0, tupleGetSize(s, targT))) {
      iType = tcTupleGetType(s, targT, i);
      InternalBitcastToRetValue::request(s, iType);
    };
    FetchProxyPointer::request(s, tupleHelperType);
  }

  private fun hhvmCopyBase(
    fs: mutable O.FunSpecializer,
    tBaseType: Type,
    obj: O.MaybeExists<O.InstrTree>,
    pos: Pos,
  ): O.MaybeExists<O.InstrTree> {
    // For a base class we create a type-switch to find the actual concrete
    // subclass and call copyToHhvm() on that.

    mut = Mutability::fromFlag(tBaseType.isMutable());

    tclasses = {
      tclasses = mutable Vector[];
      _ = tBaseType.forEachConcreteSubtype(fs, subclass -> {
        tclasses.push(Tclass(subclass.id, mut));
        true
      });
      tclasses.toArray()
    };

    cases = Array::createFromItems(
      tclasses.map(t -> fs.getSClass(t.sclassID).gclassName),
    );

    successors = cases.map(_ -> BlockSuccessor(fs.newBlockID()));

    join = fs.newBlockID();
    default = fs.newBlockID();

    F.emitTypeSwitch{
      fs,
      value => obj,
      cases,
      successors => Array[BlockSuccessor(default)].concat(successors),
      pos,
    };

    fs.startNewBlock(default);
    _ = fs.emitUnreachable{
      pos,
      why => "unknown type in copyToHhvm() type-switch",
    };

    for (i in successors.zip(tclasses)) {
      (succ, typ) = i;
      fs.startNewBlock(succ.target);
      handle = HhvmInterop.CopyToHhvm::call(fs, typ, obj, pos);
      F.emitJump{fs, target => join, args => Array[handle], pos};
    };

    blockParams = F.startNewBlock{
      fs,
      target => join,
      args => Array[tHhvmHandle],
      pos,
    };

    blockParams[0]
  }

  private fun requestHhvmCopyBase(
    s: mutable O.Specializer,
    targs: Array<Tclass>,
    _tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    retType = targs[0];

    // NOTE: Normally you can't walk subclasses during the request phase,
    // but these were all force-created before we started requesting.
    for (subtypeId in s.sclasses[retType.sclassID].subtypes) {
      subtype = Tclass(s.sclasses[subtypeId].sclass.id, retType.mutability);
      HhvmInterop.CopyToHhvm::request(s, subtype);
    }
  }
}

// Intrinsic for:
//   fun fetchProxyPointer<T>(ptr: T): Runtime.HhvmHandle;
//
extension class FetchProxyPointer extends O.CustomIntrinsic {
  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    optinfo = fs.optinfo;
    pos = gInstr.pos;
    s = fs.specializer;

    gRetType = this.funInfo.funType.returnType;
    retType = fs.specializeType(gRetType);

    F.fromExists(fs, fs.getValue(gInstr.args[0]), pos, obj_ -> {
      obj = obj_.flattened()[0].i1;
      objType = optinfo.getInstr(obj).typ;
      O.Exists(
        O.InstrLeaf(
          fs.emitCast{
            value => if (Hhvm.isHhvmProxy(s, objType, pos)) {
              fs.emitGetField{obj, field => "proxyPointer", typ => retType, pos}
                .id
            } else if (
              Hhvm.isHhvmHandle(objType) ||
              Hhvm.isHhvmShapeHandle(objType)
            ) {
              obj
            } else {
              pos.die(`Cannot call FetchProxyPointer on type ${objType}`)
            },
            typ => retType,
            pos,
          }.id,
        ),
      )
    })
  }
}

// Intrinsic for:
//   fun hhvmVariantFactory<T>(variant: NonGcPointer, value: T): void;
//
class HhvmVariantFactory extends O.CustomIntrinsic {
  const name: String = "HhvmInterop.hhvmVariantFactory";

  protected fun emitIR(
    call: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    pos = this.funInfo.pos;
    s = fs.specializer;

    targ = fs.specializeType(this.funInfo.tparams[0]);
    variant = fs.getValue(call.args[0]);
    value = fs.getValue(call.args[1]);

    factory = (
      if (targ == tBool) {
        "SKIP_HhvmVariant_fromBool"
      } else if (targ == tInt) {
        "SKIP_HhvmVariant_fromInt64"
      } else if (targ == tFloat) {
        "SKIP_HhvmVariant_fromFloat64"
      } else if (targ == tString) {
        "SKIP_HhvmVariant_fromString"
      } else if (Hhvm.isHhvmHandle(targ)) {
        "SKIP_HhvmVariant_fromObject"
      } else if (Hhvm.isHhvmImport(s, targ, pos) || Hhvm.isHhvmHandle(targ)) {
        !value = HhvmInterop.FetchProxyPointer::call(fs, targ, value, pos);
        "SKIP_HhvmVariant_fromObject"
      } else if (
        Hhvm.isHhvmArray(s, targ, pos) ||
        Hhvm.isHhvmShape(s, targ, pos)
      ) {
        !value = HhvmInterop.FetchProxyPointer::call(fs, targ, value, pos);
        "SKIP_HhvmVariant_fromArray"
      } else {
        pos.die(`hhvmVariantFactory<${targ}>(): unhandled type`)
      }
    );

    _ = F.emitNamedCall{
      fs,
      typ => tVoid,
      pos,
      name => factory,
      args => Array[variant, value],
      allocAmount => AllocBounded(),
    };

    O.Exists(O.kVoidInstrTree)
  }

  protected fun requestFunctions(
    s: mutable O.Specializer,
    targs: Array<Tclass>,
    _tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    targT = targs[0];
    if (Hhvm.isHhvmProxy(s, targT, s.pos) || Hhvm.isHhvmHandle(targT)) {
      HhvmInterop.FetchProxyPointer::request(s, targT);
    };
  }
}

base class ConvertIntrinsic extends O.CustomIntrinsic {
  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    pos = gInstr.pos;
    retType = fs.specializeType(this.funInfo.funType.returnType);
    handle = fs.getValue(gInstr.args[0]);

    F.emitReinterpret{fs, typ => retType, value => handle, pos}
  }
}

class ConvertToHhvmHandle extends ConvertIntrinsic {
  const name: String = "HhvmInterop.convertToHhvmHandle";
}

class ConvertToHhvmShapeHandle extends ConvertIntrinsic {
  const name: String = "HhvmInterop.convertToHhvmShapeHandle";
}

module end;
// -----------------------------------------------------------------------------
module Hhvm;

// Return a tuple (Int, Int) which is the standard type that we use to pass
// Mixed to the interop layer (skip::SkipRetValue).
fun getSkipRetValueType(fs: mutable O.FunSpecializer): Tclass {
  fs.specializer.getReturnTuple(Array[tInt, tInt])
}

fun copyAnnotationName(annotation: SSet, pos: Pos): ?String {
  annotationsContainParam(annotation, "@hhvm_copy", pos)
}

fun shapeCopyAnnotationName(annotation: SSet, pos: Pos): ?String {
  annotationsContainParam(annotation, "@hhvm_shape_copy", pos)
}

fun importAnnotationName(annotation: SSet, pos: Pos): ?String {
  annotationsContainParam(annotation, "@hhvm_import", pos)
}

fun exportAnnotationName(annotation: SSet, pos: Pos): ?String {
  annotationsContainParam(annotation, "@hhvm_export", pos)
}

fun arrayAnnotationName(annotation: SSet, pos: Pos): ?String {
  annotationsContainParam(annotation, "@hhvm_array", pos)
}

fun externAnnotationName(annotation: SSet, pos: Pos): ?String {
  annotationsContainParam(annotation, "@hhvm_extern", pos)
}

fun shapeAnnotationName(annotation: SSet, pos: Pos): ?String {
  annotationsContainParam(annotation, "@hhvm_shape", pos)
}

fun isCopyAnnotation(annotation: SSet, pos: Pos): Bool {
  copyAnnotationName(annotation, pos).isSome()
}

fun isShapeCopyAnnotation(annotation: SSet, pos: Pos): Bool {
  shapeCopyAnnotationName(annotation, pos).isSome()
}

fun isImportAnnotation(annotation: SSet, pos: Pos): Bool {
  importAnnotationName(annotation, pos).isSome()
}

fun isExportAnnotation(annotation: SSet, pos: Pos): Bool {
  exportAnnotationName(annotation, pos).isSome()
}

fun isArrayAnnotation(annotation: SSet, pos: Pos): Bool {
  arrayAnnotationName(annotation, pos).isSome()
}

fun isExternAnnotation(annotation: SSet, pos: Pos): Bool {
  externAnnotationName(annotation, pos).isSome()
}

fun isShapeAnnotation(annotation: SSet, pos: Pos): Bool {
  shapeAnnotationName(annotation, pos).isSome()
}

// Return true if (t matches Nullable _)
fun isNullableType(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["Nullable", "Box", "Null"])
}

fun isFlagOption(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["FastOption.FlagOption"])
}

fun isOptionType(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["FastOption.FlagOption", "FastOption.SentinelOption"])
}

// Return true if (t isa tHhvmHandle), ignoring mutability.
fun isHhvmHandle(t: Type): Bool {
  t.mapMutability(_ -> tHhvmHandle.mutability) == tHhvmHandle
}

fun isHhvmShapeHandle(t: Type): Bool {
  t.mapMutability(_ -> tHhvmShapeHandle.mutability) == tHhvmShapeHandle
}

fun flattensToHhvmHandle(fs: mutable O.FunSpecializer, typ: Type): Bool {
  shape = fs.scalarize(typ);
  types = shape.flattened().map(p -> p.i1);
  ((types.size() == 1) && isHhvmHandle(types[0]))
}

private const hhMixedClasses: Array<String> = Array[
  "HH.Arraybacked",
  "HH.Arraykey",
  "HH.Bool",
  "HH.Darray",
  "HH.Dict",
  "HH.Float",
  "HH.Int",
  "HH.Keyset",
  "HH.Map",
  "HH.Mixed",
  "HH.NonexhuastivePlaceholderObject",
  "HH.NonexhuastivePlaceholderResource",
  "HH.Nonnull",
  "HH.Null",
  "HH.Number",
  "HH.Object",
  "HH.Primitive",
  "HH.Resource",
  "HH.Set",
  "HH.String",
  "HH.Varray",
  "HH.Vec",
  "HH.Vector",
];

fun isMixedSubclass(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, hhMixedClasses)
}

fun isHHLambdaSubclass(env: readonly ClassLookupEnv, t: Type): Bool {
  t.isGeneric(env, Array["HH.Lambda", "HH.LambdaString", "HH.LambdaObject"])
}

fun flattensToSingleValue(fs: mutable O.FunSpecializer, typ: Type): Bool {
  shape = fs.scalarize(typ);
  types = shape.flattened().map(p -> p.i1);
  (types.size() == 1)
}

fun tcIsHhvmCopy(s: readonly O.Specializer, tc: Tclass, pos: Pos): Bool {
  isCopyAnnotation(s.sclasses[tc.sclassID].sclass.annotations, pos)
}

fun isHhvmCopy(s: readonly O.Specializer, t: Type, pos: Pos): Bool {
  t.forEachTclass(tc -> tcIsHhvmCopy(s, tc, pos))
}

fun tcIsHhvmShapeCopy(s: readonly O.Specializer, tc: Tclass, pos: Pos): Bool {
  isShapeCopyAnnotation(s.sclasses[tc.sclassID].sclass.annotations, pos)
}

fun isHhvmShapeCopy(s: readonly O.Specializer, t: Type, pos: Pos): Bool {
  t.forEachTclass(tc -> tcIsHhvmShapeCopy(s, tc, pos))
}

// Return true if t was annotated with @hhvm_import
fun isHhvmImport(s: readonly O.Specializer, t: Type, pos: Pos): Bool {
  sc = s.exampleSClass(t);
  isImportAnnotation(sc.annotations, pos)
}

fun gIsHhvmImport(converter: O.Converter, t: O.GType, pos: Pos): Bool {
  t match {
  | O.GTapply(generic, _, _) ->
    gc = converter.getGClass(generic, pos);
    isImportAnnotation(gc.annotations, pos)
  | _ -> false
  }
}

fun isHhvmArray(s: readonly O.Specializer, t: Type, pos: Pos): Bool {
  sc = s.exampleSClass(t);
  isArrayAnnotation(sc.annotations, pos)
}

fun gIsHhvmArray(converter: O.Converter, t: O.GType, pos: Pos): Bool {
  t match {
  | O.GTapply(generic, _, _) ->
    gc = converter.getGClass(generic, pos);
    isArrayAnnotation(gc.annotations, pos)
  | _ -> false
  }
}

fun isHhvmShape(s: readonly O.Specializer, t: Type, pos: Pos): Bool {
  sc = s.exampleSClass(t);
  isShapeAnnotation(sc.annotations, pos)
}

fun gIsHhvmShape(converter: O.Converter, t: O.GType, pos: Pos): Bool {
  t match {
  | O.GTapply(generic, _, _) ->
    gc = converter.getGClass(generic, pos);
    isShapeAnnotation(gc.annotations, pos)
  | _ -> false
  }
}

fun isHhvmProxy(s: readonly O.Specializer, t: Type, pos: Pos): Bool {
  isHhvmImport(s, t, pos) || isHhvmArray(s, t, pos) || isHhvmShape(s, t, pos)
}

fun gIsHhvmProxy(converter: O.Converter, t: O.GType, pos: Pos): Bool {
  gIsHhvmImport(converter, t, pos) ||
    gIsHhvmArray(converter, t, pos) ||
    gIsHhvmShape(converter, t, pos)
}

fun tcGetNullableTarg(s: readonly O.Specializer, tc: Tclass, pos: Pos): Tclass {
  HhvmInterop.tcGetTarg(s, tc, 0, pos)
}

fun getNullableTarg(s: readonly O.Specializer, t: Type, pos: Pos): Type {
  HhvmInterop.getTarg(s, t, 0, pos)
}

fun tcGetOptionTarg(s: readonly O.Specializer, tc: Tclass, pos: Pos): Tclass {
  HhvmInterop.tcGetTarg(s, tc, 0, pos)
}

fun getOptionTarg(s: readonly O.Specializer, t: Type, pos: Pos): Type {
  HhvmInterop.getTarg(s, t, 0, pos)
}

fun isPortableType(s: readonly O.Specializer, t: Type, pos: Pos): Bool {
  if (
    t == tBool ||
    t == tInt ||
    t == tFloat ||
    t == tString ||
    Hhvm.isHhvmProxy(s, t, pos) ||
    Hhvm.isHhvmCopy(s, t, pos) ||
    Hhvm.isHhvmShapeCopy(s, t, pos) ||
    Hhvm.isMixedSubclass(s, t) ||
    Hhvm.isHHLambdaSubclass(s, t)
  ) {
    true
  } else if (Hhvm.isNullableType(s, t)) {
    isPortableType(s, Hhvm.getNullableTarg(s, t, pos), pos)
  } else if (Hhvm.isOptionType(s, t)) {
    isPortableType(s, Hhvm.getOptionTarg(s, t, pos), pos)
  } else if (HhvmInterop.isArraylike(s, t) || HhvmInterop.isSetlike(s, t)) {
    isPortableType(s, HhvmInterop.getTarg(s, t, 0, pos), pos)
  } else if (HhvmInterop.isMaplike(s, t)) {
    isPortableType(s, HhvmInterop.getTarg(s, t, 0, pos), pos) &&
      isPortableType(s, HhvmInterop.getTarg(s, t, 1, pos), pos)
  } else if (HhvmInterop.isTuple(s, t)) {
    Range(0, HhvmInterop.tupleGetSize(s, t)).all(i -> {
      isPortableType(s, HhvmInterop.tupleGetType(s, t, i), pos)
    })
  } else {
    false
  }
}

// Given (value: SkipRetValue) convert it into a Nullable<typ>
// Turn fields such as
//   x:Int
// into:
//   fun .get.x(): Int {
//     HhvmInterop.propertyGetHelper<readonly classname, Int>(this, "x")
//   }
//   mutable fun .set.x(value: Int): void {
//     HhvmInterop.propertySetHelper<mutable classname, Int>(this, "x", value)
//   }
//
fun addHhvmProperty(
  converter: O.Converter,
  methods: mutable UnorderedMap<String, O.GMethodDef>,
  in_: I.Parameter,
  containingClass: FrontEndLazyGClass,
  classTparams: Array<O.GTparam>,
  pos: FileRange,
  addSetter: Bool,
): void {
  name = in_.name.id;
  met_class = I.Name(pos, containingClass.id);
  typedClass = I.Type(pos, I.Tapply(met_class, Array[]));
  mutableTypedClass = I.Type(pos, I.Tmutable(typedClass));

  {
    funName = ".get." + name;

    funInfo = O.GFunInfo{
      gfunction => GFunctionName(`${containingClass.id}::${funName}`),
      pos,
      isNative => false,
      isMemoized => false,
      className => Some(containingClass.name()),
      isAsync => false,
      annotations => SSet[],
      tparams => classTparams,
      funType => O.makeGFunTypeWithFlags{
        paramTypes => converter.convertTypes(
          Array[I.Type(pos, I.Treadonly(typedClass))],
        ),
        numOptional => 0,
        returnType => converter.convertType(in_.type),
        isMutable => false,
        isTracked => true,
      },
    };

    paramType = converter.convertType(in_.type);

    params = Array[
      O.ParameterInfo{
        name => "this",
        value => None(),
        info => SkipOuterIstUtils.const_binding_info,
        index => -1,
        pos,
      },
    ];

    lazyFun = O.CustomLazyGFun{
      funInfo,
      params,
      emitBodyHelper => e ~> {
        e.emitReturn(
          e.emitCallFunction(
            HhvmInterop.PropertyGetHelper::funName(),
            /* args */ Array[
              e.params[0],
              e.constantString(UTF8String::make(name)),
            ],
            /* targs */ Array[
              O.GTapply(containingClass, Readonly()),
              paramType,
            ],
            /* ret */ paramType,
            pos,
          ),
          pos,
        );
      },
    };

    methods.add(
      funName,
      O.GMethodDef{
        function => Some(_ ~> lazyFun),
        tparams => Array[],
        tparamInherit => UnorderedMap[],
        pos,
      },
    );
  };

  if (addSetter) {
    funName = ".set." + name;

    funInfo = O.GFunInfo{
      gfunction => GFunctionName(`${containingClass.nameStr()}::${funName}`),
      pos,
      isNative => false,
      isMemoized => false,
      className => Some(containingClass.name()),
      isAsync => false,
      annotations => SSet[],
      tparams => classTparams,
      funType => O.makeGFunTypeWithFlags{
        paramTypes => converter.convertTypes(
          Array[mutableTypedClass, in_.type],
        ),
        numOptional => 0,
        returnType => O.gtVoid,
        isMutable => true,
        isTracked => true,
      },
    };

    paramType = converter.convertType(in_.type);

    params = Array[
      O.ParameterInfo{
        name => "this",
        value => None(),
        info => SkipOuterIstUtils.unused_binding_info,
        index => -1,
        pos,
      },
      O.ParameterInfo{
        name => "value",
        value => None(),
        info => SkipOuterIstUtils.const_binding_info,
        index => 0,
        pos,
      },
    ];

    lazyFun = O.CustomLazyGFun{
      funInfo,
      params,
      emitBodyHelper => e ~> {
        _ = e.emitCallFunction(
          O.FrontEndLazyGFun{frontEndName => "HhvmInterop.propertySetHelper"},
          /* args */ Array[
            e.params[0],
            e.constantString(UTF8String::make(name)),
            e.params[1],
          ],
          /* targs */ Array[O.GTapply(containingClass, Mutable()), paramType],
          /* ret */ O.gtVoid,
          pos,
        );
        _ = e.emitReturn(e.constantVoid(), pos);
      },
    };

    methods.add(
      funName,
      O.GMethodDef{
        function => Some(_ ~> lazyFun),
        tparams => Array[],
        tparamInherit => UnorderedMap[],
        pos,
      },
    );
  };
}

// Create properties for each of the fields of an @hhvm_import class
fun setUpStandardImportMethods(
  converter: O.Converter,
  methods: mutable UnorderedMap<String, O.GMethodDef>,
  classname: FrontEndLazyGClass,
  params: ?I.ClassParams,
  tparams: Array<O.GTparam>,
  pos: FileRange,
  addSetter: Bool,
): void {
  params match {
  | Some(cp) ->
    cp.params.each(param -> {
      Hhvm.addHhvmProperty(
        converter,
        methods,
        param,
        classname,
        tparams,
        pos,
        addSetter,
      );
    })
  | _ -> void
  };
}

fun convertIntrinsic(
  name: String,
  funInfo: O.GFunInfo,
  params: Array<O.ParameterInfo>,
): ?O.LazyGFun {
  name match {
  | "HhvmInterop.convertToHhvmHandle" ->
    Some(HhvmInterop.ConvertToHhvmHandle::make(funInfo, params))
  | "HhvmInterop.convertToHhvmShapeHandle" ->
    Some(HhvmInterop.ConvertToHhvmShapeHandle::make(funInfo, params))
  | "HhvmInterop.copyFromHhvm" ->
    Some(HhvmInterop.CopyFromHhvm::make(funInfo, params))
  | "HhvmInterop.copyToHhvm" ->
    Some(HhvmInterop.CopyToHhvm::make(funInfo, params))
  | "HhvmInterop.createFromProxyPointer" ->
    Some(HhvmInterop.CreateFromProxyPointer::make(funInfo, params))
  | "HhvmInterop.createFromProxyPointerAndType" ->
    Some(HhvmInterop.CreateFromProxyPointerAndType::make(funInfo, params))
  | "HhvmInterop.fetchProxyPointer" ->
    Some(HhvmInterop.FetchProxyPointer::make(funInfo, params))
  | "Svmi.hhvmTypeTable" ->
    Some(HhvmInterop.HhvmTypeTableFun::make(funInfo, params))
  | "HhvmInterop.hhvmVariantFactory" ->
    Some(HhvmInterop.HhvmVariantFactory::make(funInfo, params))
  | "HhvmInterop_Gather.deserializeKBase" ->
    Some(HhvmInterop_Gather.DeserializeKBase::make(funInfo, params))
  | "HhvmInterop_Gather.gatherConvert" ->
    Some(HhvmInterop_Gather.GatherConvert::make(funInfo, params))
  | "HhvmInterop_Gather.fetchRawScalar" ->
    Some(HhvmInterop_Gather.FetchRawScalar::make(funInfo, params))
  | "HhvmInterop_PropertyGetHelper.internalBitcastFromInt" ->
    Some(
      HhvmInterop_PropertyGetHelper.InternalBitcastFromInt::make(
        funInfo,
        params,
      ),
    )
  | "HhvmInterop.internalBitcastToRetValue" ->
    Some(HhvmInterop.InternalBitcastToRetValue::make(funInfo, params))
  | "HhvmInterop_PropertyGetHelper.internalCreateFromRetValue" ->
    Some(
      HhvmInterop_PropertyGetHelper.InternalCreateFromRetValue::make(
        funInfo,
        params,
      ),
    )
  | "HhvmInterop.internalCreateFrozenFromItems" ->
    Some(HhvmInterop.InternalCreateFrozenFromItems::make(funInfo, params))
  | "HhvmInterop.internalCreateFrozenFromIterator" ->
    Some(HhvmInterop.InternalCreateFrozenFromIterator::make(funInfo, params))
  | "HhvmInterop.internalCreateMutableFromItems" ->
    Some(HhvmInterop.InternalCreateMutableFromItems::make(funInfo, params))
  | "HhvmInterop.internalCreateMutableFromIterator" ->
    Some(HhvmInterop.InternalCreateMutableFromIterator::make(funInfo, params))
  | "HhvmInterop_PropertyGetHelper.internalCreateNonNullableFromRetValue" ->
    Some(
      HhvmInterop_PropertyGetHelper.InternalCreateNonNullableFromRetValue::make(
        funInfo,
        params,
      ),
    )
  | "HhvmInterop_PropertySetHelper.internalSetProperty" ->
    Some(
      HhvmInterop_PropertySetHelper.InternalSetProperty::make(funInfo, params),
    )
  | "HhvmInterop_PropertySetHelper.internalSetPropertyToNull" ->
    Some(
      HhvmInterop_PropertySetHelper.InternalSetPropertyToNull::make(
        funInfo,
        params,
      ),
    )
  | "HhvmInterop_PropertySetHelper.internalSetPropertyToUndefined" ->
    Some(
      HhvmInterop_PropertySetHelper.InternalSetPropertyToUndefined::make(
        funInfo,
        params,
      ),
    )
  | "HhvmInterop.propertyGetHelper" ->
    Some(HhvmInterop.PropertyGetHelper::make(funInfo, params))
  | "HhvmInterop.propertySetHelper" ->
    Some(HhvmInterop.PropertySetHelper::make(funInfo, params))
  | _ -> None()
  }
}

// convert:
//   @hhvm_extern(name)
//   fun myfun<T>(args...): Ret;
// to:
//   fun myfun<T>(args...): Ret {
//     mangled_name(converted args...);
//   }
//
class HhvmRuntimeLazyGFun extends O.CustomIntrinsic {
  const name: String = "<runtime-lazy-fun>";

  protected fun emitIR(
    gInstr: O.GCustomInstr,
    fs: mutable O.FunSpecializer,
  ): O.MaybeExists<O.InstrTree> {
    optinfo = fs.optinfo;
    pos = gInstr.pos;
    s = fs.specializer;

    gRetType = this.funInfo.funType.returnType;
    retType = fs.specializeType(gRetType);

    // Go through the params and convert any @hhvm_import or @hhvm_array into a
    // tHhvmHandle
    specializedParams = gInstr.args.map(arg -> {
      (fs.specializeType(arg.getType()), fs.getValue(arg))
    });

    params = specializedParams.map(i -> {
      (typ, value) = i;
      if (isHhvmProxy(s, typ, pos) && !flattensToHhvmHandle(fs, typ)) {
        HhvmInterop.FetchProxyPointer::call(fs, typ, value, pos);
      } else {
        value
      }
    });

    mangledParams = mutable Vector[];
    for (i in specializedParams) {
      (typ, _) = i;
      NameMangler.fromNonVoidType(
        if (isHhvmProxy(s, typ, pos)) {
          // We fetch the proxyPointer to make this true further down...
          tHhvmHandle
        } else {
          typ
        },
        fs,
        pos,
      ) match {
      | Some(p) -> mangledParams.push(p)
      | None() -> void
      };
    };

    F.fromExists(fs, fs.flattenArgs(params), pos, flatParams -> {
      flatParamTypes = flatParams.map(id -> optinfo.getInstr(id).typ);

      if (isHhvmProxy(s, retType, pos) && !flattensToHhvmHandle(fs, retType)) {
        // If the return type is @hhvm_import or @hhvm_array (and not a raw
        // tHhvmHandle) then we need to provide a factory to build that object.
        (funName, factoryParams) = if (isHhvmImport(s, retType, pos)) {
          (
            HhvmInterop.CreateFromProxyPointerAndType::funName(),
            Array[NameMangler.skipHhvmHandlePtr, NameMangler.skipString],
          )
        } else {
          (
            HhvmInterop.CreateFromProxyPointer::funName(),
            Array[NameMangler.skipHhvmHandlePtr],
          )
        };
        targs = Array[gRetType];
        smap = fs.getFunSMap(targs);
        factory = fs.computeSFunctionID(funName, smap, pos);
        factoryId = fs.constantFun(factory).id;
        !params = Array[O.Exists(O.InstrLeaf(factoryId))].concat(params);
        !flatParams = Array[factoryId].concat(flatParams);
        !flatParamTypes = Array[tNonGCPointer].concat(flatParamTypes);
        mangledParams.insert(
          0,
          NameMangler.Ptr{
            child => NameMangler.Function{
              returnType => NameMangler.skipRObjPtr,
              params => factoryParams,
            },
          },
        );
      };

      convertReturn = v -> v;

      mangledRetType = NameMangler.fromType(retType, fs, pos);

      if (Hhvm.isMixedSubclass(s, retType)) {
        !mangledRetType = NameMangler.LiteralSeq["SkipRetValue"];
        oldRet = retType;
        !retType = Hhvm.getSkipRetValueType(fs);
        !convertReturn = v ->
          F.emitCast{
            fs,
            typ => oldRet,
            value => HhvmInterop_PropertyGetHelper.InternalCreateMixedFromRetValue::call(
              fs,
              v,
              oldRet,
              pos,
            ),
            pos,
          };
      } else if (Hhvm.isFlagOption(s, retType)) {
        !mangledRetType = NameMangler.LiteralSeq["SkipRetValue"];
        targT = Hhvm.getOptionTarg(s, retType, pos);
        !retType = Hhvm.getSkipRetValueType(fs);
        !convertReturn = v ->
          HhvmInterop_PropertyGetHelper.InternalCreateOptionFromRetValue::call(
            fs,
            targT,
            v,
            pos,
          );
      };

      name = Hhvm.externAnnotationName(optinfo.f.annotations, pos).maybe(
        optinfo.f.gfunction.id,
        just -> if (just.isEmpty()) optinfo.f.gfunction.id else just,
      );
      mangledName = NameMangler.hhvmMangledName(
        name,
        mangledRetType,
        mangledParams.toArray(),
      );

      targetFun = Function{
        name => mangledName,
        pos,
        id => fs.msfuns.allocID(),
        params => flatParamTypes.mapWithIndex((i, typ) ->
          FunParam{id => InstrID(i), pos, typ}
        ),
        blocks => Array[],
        isRuntimeExport => true,
        superpositions => UnorderedSet[FunSuperpositionID::empty],
        funType => Tfun{
          isMutable => true,
          isTracked => false,
          params => flatParamTypes,
          returnType => fs.scalarize(retType).flattened().map(p -> p.i1),
          aggregateReturnType => retType,
        },
        isNative => true,
        gfunction => GFunctionName(mangledName),
        annotations => SSet[`@cpp_extern("${mangledName}")`],
      };
      fs.msfuns.insert(targetFun);

      result = F.emitCallFunction{
        fs,
        name => targetFun.id,
        smap => fs.getFunSMap(Array[]),
        args => params,
        typ => retType,
        pos,
      };

      convertReturn(result)
    });
  }

  protected fun requestFunctions(
    s: mutable O.Specializer,
    _targs: Array<Tclass>,
    tparamEnv: UnorderedMap<O.GTparam, Tclass>,
  ): void {
    pos = s.pos;
    for (p in this.funInfo.funType.params) {
      tc = s.getTclass3(p, tparamEnv);
      if (isHhvmProxy(s, tc, pos)) {
        HhvmInterop.FetchProxyPointer::request(s, tc)
      }
    };

    retType = s.getTclass3(this.funInfo.funType.returnType, tparamEnv);
    if (isHhvmImport(s, retType, s.pos)) {
      HhvmInterop.CreateFromProxyPointerAndType::request(s, retType);
    } else if (isHhvmArray(s, retType, pos) || isHhvmShape(s, retType, pos)) {
      HhvmInterop.CreateFromProxyPointer::request(s, retType);
    } else if (isMixedSubclass(s, retType)) {
      HhvmInterop_PropertyGetHelper.InternalCreateMixedFromRetValue::request(s);
    } else if (isOptionType(s, retType)) {
      HhvmInterop_PropertyGetHelper.InternalCreateOptionFromRetValue::request(
        s,
        Hhvm.tcGetOptionTarg(s, retType, s.pos),
      );
    }
  }
}
