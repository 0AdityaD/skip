/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

module alias TAst = SkipTypedAst;
module alias O = OuterIst;
module alias OIU = SkipOuterIstUtils;
module alias AU = SkipAstUtils;
module alias JS = SkipJsIst;
module alias JSU = SkipJsIstUtils;

/* route to tail-recursive sk_* but preserve ocaml param order */
module SkipTranscompileJs;

mutable class Context{
  new_id: () -> Int,
  type_switch_ids: SMap<Int>,
  program: O.Program,
}

fun create_context(new_id: () -> Int, program: O.Program): mutable Context {
  mutable Context{
    new_id,
    type_switch_ids => OIU.assign_type_switch_ids(
      program.class_defs,
      OIU.create_derived_classes(program.class_defs),
    ),
    program,
  };
}

fun get_type_switch_id(context: mutable Context, class_name: String): Int {
  context.type_switch_ids[class_name]
}

fun get_class_of_context(
  context: mutable Context,
  class_name: String,
): O.ClassDef {
  context.program.class_defs.getOrCrash(class_name)
}

fun is_class_known_to_be_immutable(cls: O.ClassDef): Bool {
  // We can only trust mutable_ on "final" classes. It just means
  // no fields known here are assignable, but subclasses could add more.
  (cls.mutable_.isNone() &&
    // singleton classes are always immutable, though they may be marked
    cls.kind == O.KClass()) ||
    // mutable if their base class has type parameters
    OIU.class_is_singleton(cls)
}

fun local_to_expression(lv: O.LocalVar): JS.Pos_expression {
  JSU.make_identifier(lv.name)
}

fun binding_to_identifier(b: O.Binding): O.Name {
  O.Name(b.name.pos, JSU.name_to_identifier(b.name))
}

fun param_to_string(param: O.Binding): String {
  JSU.name_to_identifier(param.name)
}

fun parameter_names(params: Parameters<O.Parameter>): Array<String> {
  params match {
  | Positional(params1) ->
    params1.map(param -> JSU.name_to_identifier(param.name))
  | Named(params1) -> params1.rawKeys().collect(Array)
  }
}

fun is_native_class(cls: O.ClassDef): Bool {
  is_native_method = (met: O.MethodDef) -> met.native_.isSome();
  cls.native_.isSome() || cls.methods.values().any(is_native_method)
}

/* TODO: Replace all uses of these with something useful */
fun todo_statement(message: String): JS.Pos_statement {
  JSU.make_throw_string("TODO: " + message)
}

fun todo_expression(message: String): JS.Pos_expression {
  JSU.statement_to_expression(todo_statement(message))
}

/* replace an assert false with this function to show which pattern is missing */
fun assert_unbound_expr<Ta>(expr: O.Expr): Ta {
  expr.expr match {
  | O.Unreachable() -> expr.pos.die("assert false")
  | O.DefaultArg() -> expr.pos.die("assert false")
  | O.ELiteral _ -> expr.pos.die("assert false")
  | O.Const _ -> expr.pos.die("assert false")
  | O.Local _ -> expr.pos.die("assert false")
  | O.Object _ -> expr.pos.die("assert false")
  | O.Call _ -> expr.pos.die("assert false")
  | O.FunCall _ -> expr.pos.die("assert false")
  | O.StaticDot _ -> expr.pos.die("assert false")
  | O.StaticCall _ -> expr.pos.die("assert false")
  | O.MethodCall _ -> expr.pos.die("assert false")
  | O.Dot _ -> expr.pos.die("assert false")
  | O.Lambda _ -> expr.pos.die("assert false")
  | O.EArray _ -> expr.pos.die("assert false")
  | O.Await _ -> expr.pos.die("assert false")
  | O.Async _ -> expr.pos.die("assert false")
  | O.Freeze _ -> expr.pos.die("assert false")
  | O.Classname _ -> expr.pos.die("assert false")
  | O.With _ -> expr.pos.die("assert false")
  | O.Cast _ -> expr.pos.die("assert false")
  | O.DynamicConstruction _ -> expr.pos.die("assert false")
  | O.GetClass _ -> expr.pos.die("assert false")
  }
}

fun make_throw_unmatched_branch(): JS.Pos_statement {
  JSU.make_throw_string("Unmatched Branch")
}

/* A.2 Expressions */
fun convert_expr_(context: mutable Context, ex: O.Expr): JS.Pos_expression {
  (pos, expr) = (ex.pos, ex.expr);
  expr match {
  | O.Unreachable() -> (pos, JS.Null())
  | O.DefaultArg() -> JSU.undefined_expr(pos)
  | O.ELiteral(value) -> convert_literal(pos, value)
  | O.Const(name) -> JSU.paramless_call(JSU.make_sk_var_name(name))
  | O.Local(name) ->
    id = name.id;
    id match {
    | "this" | "static" -> JSU.make_this(pos)
    | _ -> JSU.make_identifier(name)
    }
  | O.DynamicConstruction(e, _, _, arguments) ->
    JSU.make_new_expression(
      JSU.make_paren_expression(convert_expr(context, e)),
      convert_arguments(context, arguments),
    )
  | O.Object(name, _, arguments) -> convert_object(context, name, arguments)
  | O.StaticCall(O.DotInfo{field => field, obj_expr => obj_expr}, arguments)
  | O.MethodCall(O.DotInfo{field => field, obj_expr => obj_expr}, arguments) ->
    /* optimize member access on LHS of Call */
    JSU.make_call_expr(
      JSU.make_member_access(convert_expr(context, obj_expr), field),
      convert_arguments(context, arguments),
    )
  | O.FunCall(name, _, arguments) ->
    JSU.make_call_expr(
      JSU.make_sk_var_name(name),
      convert_arguments(context, arguments),
    )
  | O.Call(func, arguments) ->
    JSU.make_call_expr(
      convert_expr(context, func),
      convert_arguments(context, arguments),
    )
  | O.StaticDot(O.DotInfo{field, obj_expr, elt_kind})
  | O.Dot(O.DotInfo{field, obj_expr, elt_kind}) ->
    /* Must get correct this binding if the context is not a call */
    elt_kind match {
    | O.EMethod() -> JSU.make_bind(convert_expr(context, obj_expr), field)
    | _ -> JSU.make_member_access(convert_expr(context, obj_expr), field)
    }
  | O.Lambda(params, _, _, stmt, yields) ->
    convert_lambda(context, pos, params, stmt, yields.isSome())
  | O.EArray(values) -> convert_vector(context, values)
  | O.Await(expr1) ->
    JSU.make_paren_expression((pos, JS.Yield(convert_expr(context, expr1))))
  | O.Async(stmt, expr1) -> convert_async(context, stmt, expr1)
  | O.Freeze(expr1) -> convert_freeze(context, expr1)
  | O.Classname(name) -> JSU.make_sk_var_name(name)
  | O.With(obj, updates) -> convert_with(context, obj, updates)
  | O.Cast(_, expr1) -> convert_expr(context, expr1)
  | O.GetClass(expr1) -> convert_get_class(context, expr1)
  }
}

fun convert_tuple_get(
  context: mutable Context,
  expr: O.Expr,
  index: Int,
): JS.Pos_expression {
  /* expr[index] */
  JSU.make_array_access(
    convert_expr(context, expr),
    JSU.make_int_literal(FileRange.none, index),
  )
}

/* e.__constructor */
fun convert_get_class(
  context: mutable Context,
  expr: O.Expr,
): JS.Pos_expression {
  JSU.make_member_access(
    convert_expr(context, expr),
    JSU.make_predefined_name(JSU.__constructor),
  )
}

// async function() { stmt; return expr; }
fun convert_async(
  context: mutable Context,
  stmt: O.Stmt,
  expr: O.Expr,
): JS.Pos_expression {
  JSU.paramless_call(
    JSU.make_asyncify(
      (
        FileRange.none,
        JS.Function(
          JS.Function_definition{
            function_is_generator => true,
            function_name => "",
            function_parameters => List[],
            function_body => List[
              convert_stmt(context, stmt),
              JSU.make_return(convert_expr(context, expr)),
            ],
          },
        ),
      ),
    ),
  )
}

/*
  (function() {
    var tmp = oldObj.__copy();
    tmp.a = newA;
    tmp.b = newB;
    return tmp;
  })()
*/
fun convert_with(
  context: mutable Context,
  obj: O.Expr,
  updates: UMap<O.WithUpdate>,
): JS.Pos_expression {
  copied_obj_name = JSU.make_predefined_name(new_tmp_sk(context.new_id));
  JSU.statements_to_expression(
    List[
      List[
        JSU.make_var_init(
          copied_obj_name,
          JSU.make_call_expr(
            JSU.make_member_access(
              convert_expr(context, obj),
              JSU.make_predefined_name(JSU.__copy),
            ),
            List[],
          ),
        ),
      ],

      updates.items().map(n_e -> {
        ((_, name), update) = n_e;
        JSU.make_assign_statement(
          JSU.make_dotted_name(
            copied_obj_name,
            // TODO: how to get the position?
            JSU.make_predefined_name(name),
          ),
          convert_expr(context, update.expr),
        )
      }) |> List::createFromIterator,
      List[JSU.make_return(JSU.make_identifier(copied_obj_name))],
    ].flatten(),
  )
}

fun convert_freeze(context: mutable Context, obj: O.Expr): JS.Pos_expression {
  JSU.make_deep_freeze(convert_expr(context, obj))
}

fun convert_literal(
  pos: FileRange,
  value: OuterIst.Literal,
): JS.Pos_expression {
  value match {
  | OuterIst.LBool(value1) -> JSU.make_bool(pos, value1)
  | OuterIst.LInt(value1) -> JSU.make_int(pos, value1)
  | OuterIst.LFloat(value1) -> JSU.make_float(pos, value1)
  | OuterIst.LString(value1) -> JSU.make_string(pos, value1)
  | OuterIst.LChar(ch) -> JSU.make_char(pos, ch)
  | OuterIst.LVoid() ->
    JSU.make_sk_private_name(JSU.make_predefined_name(JSU._void))
  }
}

fun convert_literal_to_case(value: OuterIst.Literal): JS.Pos_expression {
  value match {
  | O.LBool(value1) -> JSU.make_bool_literal(FileRange.none, value1)
  | O.LInt(value1) -> JSU.make_int_literal(FileRange.none, value1)
  | O.LFloat(value1) -> JSU.make_float_literal(FileRange.none, value1)
  | O.LString(value1) -> JSU.make_string_literal(FileRange.none, value1)
  | O.LChar(ch) -> JSU.make_char_literal(FileRange.none, ch)
  | O.LVoid() -> invariant_violation("Should have been converted to Pat_all")
  }
}

fun convert_expr(context: mutable Context, expr: O.Expr): JS.Pos_expression {
  convert_expr_(context, expr)
}

fun convert_exprs(
  context: mutable Context,
  exprs: List<O.Expr>,
): List<JS.Pos_expression> {
  exprs.map(e -> convert_expr(context, e))
}

fun convert_vector(
  context: mutable Context,
  values: Array<O.Expr>,
): JS.Pos_expression {
  JSU.make_new_expression(
    JSU.make_paren_expression(
      JSU.make_sk_var_name(JSU.make_predefined_name(JSU.array_class)),
    ),
    List[JSU.make_array(convert_exprs(context, List::createFromItems(values)))],
  )
}

fun convert_lambda_params(params: Parameters<O.Binding>): Array<String> {
  params match {
  | Positional(params1) -> params1.map(p -> JSU.name_to_identifier(p.name))
  | Named _ -> Array[JSU.__named_parameters]
  }
}

fun convert_named_lambda_param_initializer(
  param: ((FileRange, String), O.Binding),
): JS.Pos_statement {
  param match {
  | ((_, name), binding) ->
    JSU.make_var_init(
      JSU.make_predefined_name(JSU.name_to_identifier(binding.name)),
      JSU.make_dotted_name(
        JSU.make_predefined_name(JSU.__named_parameters),
        JSU.make_predefined_name(name),
      ),
    )
  }
}

fun convert_lambda_named_params(
  params: Parameters<O.Binding>,
): List<JS.Pos_statement> {
  params match {
  | Positional _ -> List[]
  | Named(params1) ->
    params1.items().map(convert_named_lambda_param_initializer) |>
      List::createFromIterator
  }
}

fun convert_lambda_body(
  context: mutable Context,
  isGenerator: Bool,
  body: O.Stmt,
  params: Parameters<O.Binding>,
): JS.Block_statement {
  block = convert_lambda_named_params(params).concat(
    JSU.statement_to_list(convert_return_stmt(context, body)),
  );
  if (isGenerator) {
    block_to_generator(block);
  } else {
    block;
  }
}

fun convert_lambda(
  context: mutable Context,
  pos: FileRange,
  params: Parameters<O.Binding>,
  stmt: O.Stmt,
  isGenerator: Bool,
): JS.Pos_expression {
  /* Don't need to use locals as we declare with 'var' at the point of binding. */
  JSU.make_lambda_expression(
    pos,
    List::createFromItems(convert_lambda_params(params)),
    convert_lambda_body(context, isGenerator, stmt, params),
  )
}

fun convert_named_arguments(
  context: mutable Context,
  arguments: UMap<O.Expr>,
): JS.Pos_expression {
  (
    FileRange.none,
    JS.Object(
      arguments.items().map(n_e -> {
        ((_, name), expr) = n_e;
        (JSU.string_to_identifier(name), convert_expr(context, expr))
      }) |> List::createFromIterator,
    ),
  )
}

fun convert_arguments(
  context: mutable Context,
  arguments: Parameters<O.Expr>,
): List<JS.Pos_expression> {
  arguments match {
  | Positional(arguments1) ->
    convert_exprs(context, List::createFromItems(arguments1))
  | Named(arguments1) -> List[convert_named_arguments(context, arguments1)]
  }
}

fun create_contructor_call(
  context: mutable Context,
  name: O.Name,
  arguments: Parameters<O.Expr>,
): JS.Pos_expression {
  JSU.make_new_expression(
    JSU.make_paren_expression(JSU.make_sk_var_name(name)),
    convert_arguments(context, arguments),
  )
}

fun singleton_name_of_class(class_def: O.ClassDef): O.Name {
  JSU.singleton_name_of_class_name(class_def.name.id)
}

fun convert_object(
  context: mutable Context,
  name: O.Name,
  arguments: Parameters<O.Expr>,
): JS.Pos_expression {
  class_def = get_class_of_context(context, name.id);
  if (OIU.class_is_singleton(class_def)) {
    JSU.make_identifier(singleton_name_of_class(class_def))
  } else {
    JSU.make_new_expression(
      JSU.make_paren_expression(JSU.make_sk_var_name(name)),
      convert_arguments(context, arguments),
    )
  }
}

/* A.3 Statements */
/* Converts a skip statement. */
fun convert_stmt(context: mutable Context, stmt: O.Stmt): JS.Pos_statement {
  stmt match {
  | O.SingleExpr(expr) ->
    JSU.make_expression_statement(convert_expr(context, expr))
  | O.Bind(left, init_opt) -> convert_bind(context, left, init_opt)
  | O.Seq(stmts) -> JSU.make_block(convert_stmt_seq(context, stmts))
  | O.If(cond, true_clause, false_clause) ->
    JSU.make_if(
      JSU.make_get_value(convert_expr(context, cond)),
      convert_stmt(context, true_clause),
      Some(convert_stmt(context, false_clause)),
    )
  | O.Match _ -> invariant_violation("assert false")
  | O.Try _ -> invariant_violation("assert false")
  | O.Throw(expr) -> JSU.make_throw(convert_expr(context, expr))
  | O.Assign(local, value) ->
    JSU.make_assign_statement(
      local_to_expression(local),
      convert_expr(context, value),
    )
  | O.AssignField(local, _, name, value) ->
    convert_assign_field(context, local, name, value)
  | O.Return(e) -> JSU.make_return(convert_expr(context, e))
  | O.Switch(expr, branches, default) ->
    convert_switch(context, expr, branches, default)
  | O.TypeSwitch(expr, branches, default) ->
    convert_type_switch(context, expr, branches, default)
  | O.TryCatch(_, body, ex, sk_catch) ->
    convert_try(context, body, ex, sk_catch)
  | O.LoopForever(pos, b) ->
    (
      pos,
      JS.Do(
        convert_stmt(context, b),
        JSU.make_bool_literal(FileRange.none, true),
      ),
    )
  | O.JumpTo(label) ->
    pos = label.pos;
    label1 = JSU.name_to_identifier(label);
    (pos, JS.Break(Some(label1)))
  | O.JumpBlock(lblstmts, _) ->
    JSU.make_block(List[convert_jump_stmts(context, lblstmts)])
  | O.Yield(e) ->
    // yield(Some(e));
    JSU.make_expression_statement(
      (
        e.pos,
        JS.Yield(
          JSU.make_new_expression(
            JSU.make_sk_var_name(JSU.make_predefined_name(JSU.Some)),
            List[convert_expr(context, e)],
          ),
        ),
      ),
    )
  | O.YieldBreak(pos) -> JSU.make_return(JSU.undefined_expr(pos))
  }
}

/*
   Since the "jumps" in javascript are restricted, we recreate forward jumps by
   performing the following transformation:
   1. Reverse the labeled statements: [l1, l2,...ln] => [ln, ..., l2, l1]
   2. Then nest these reversed statements:
      - convert_jump_stmts(ls) => jumpBlockOuter: {convert_inner_jumps(ls)}
      - convert_inner_jumps([]) => {}
      - convert_inner_jumps((lab, stmt)::rest) =>
       lab: {
              convert_inner_jumps(rest);
            };
            convert_stmt(stmt);
            Break (Some jumpBlockOuter);

   e.g.
   JumpBlock [
     ("baz", s3)
     ("bar", s2);
     ("foo", s1);
   ]
   ==>
   jumpBlockOuter: {
     foo: {
       bar: {
          *** baz: { } (Omitted! Since it's dead)
         <s3>
         break jumpBlockOuter;
       }
       <s2>
       break jumpBlockOuter;
     }
     <s1>
     break jumpBlockOuter;
   }
*/
fun convert_jump_stmts(
  context: mutable Context,
  stmts: List<O.LabeledStmt>,
): JS.Pos_statement {
  reversed_jumps = stmts.reversed();
  reversed_jumps match {
  | List.Nil() -> (FileRange.none, JS.Empty())
  | List.Cons(O.LabeledStmt(top_name, _), _) ->
    top_level_label = "jumpBlockOuter" + JSU.name_to_identifier(top_name);
    break_top = (FileRange.none, JS.Break(Some(top_level_label)));
    inner_stmts = convert_inner_jumps(context, reversed_jumps, break_top);
    JSU.make_named_block(top_level_label, inner_stmts)
  }
}

fun convert_inner_jumps(
  context: mutable Context,
  jump_stmts: List<O.LabeledStmt>,
  jump_end: JS.Pos_statement,
): List<JS.Pos_statement> {
  jump_stmts match {
  | List.Nil() -> List[(FileRange.none, JS.Empty())]
  | List.Cons(O.LabeledStmt(_, stmt), List.Nil()) ->
    List[convert_stmt(context, stmt)]
  | List.Cons(O.LabeledStmt(lbl, stmt), rest) ->
    label = JSU.name_to_identifier(lbl);
    tail = if (OIU.is_statement_end_reachable(stmt)) {
      List[jump_end]
    } else {
      List[]
    };
    List.Cons(
      JSU.make_named_block(label, convert_inner_jumps(context, rest, jump_end)),
      List.Cons(convert_stmt(context, stmt), tail),
    )
  }
}

// local.name = value
fun convert_assign_field(
  context: mutable Context,
  local: O.LocalVar,
  name: O.Name,
  value: O.Expr,
): JS.Pos_statement {
  assign = JSU.make_assign(
    JSU.make_member_access(local_to_expression(local), name),
    convert_expr(context, value),
  );
  JSU.make_expression_statement(assign)
}

/* TODO: Handle case targets which are ints > 53-bits */
fun convert_switch(
  context: mutable Context,
  expr: O.Expr,
  branches: List<O.SwitchBranch>,
  default: ?O.Stmt,
): JS.Pos_statement {
  /* switch expr is the JavaScript value that is the switched on */
  switch_expr = JSU.make_predefined_name(new_tmp_sk(context.new_id));
  convert_branch = b -> {
    converted_body = convert_stmt(context, b.action);
    JS.Case(
      b.cases.map(p -> convert_literal_to_case(p.i1)),
      if (OIU.is_statement_end_reachable(b.action)) {
        List[converted_body, (FileRange.none, JS.Break(None()))]
      } else {
        List[converted_body]
      },
    )
  };
  JSU.make_block(
    List[
      JSU.make_var_init(
        switch_expr,
        JSU.make_get_switch_value(convert_expr(context, expr)),
      ),

      (
        FileRange.none,
        JS.Switch(
          JS.Switch_statement{
            switch_expression => JSU.make_identifier(switch_expr),
            switch_cases => branches
              .map(convert_branch)
              .concat(
                List[
                  (JS.Default(
                    List[make_default_statement(context, default)],
                  ) : JS.Case_clause),
                ],
              ),
          },
        ),
      ),
    ],
  )
}

fun convert_type_switch(
  context: mutable Context,
  expr: O.Expr,
  branches: List<O.TypeSwitchBranch>,
  default: ?O.Stmt,
): JS.Pos_statement {
  (
    expr.pos,
    JS.Switch(
      JS.Switch_statement{
        switch_expression => JSU.make_get_type_switch_value(
          convert_expr(context, expr),
        ),
        switch_cases => branches
          .map(branch -> convert_type_switch_branch(context, branch))
          .concat(
            List[
              JS.Default(
                JSU.statement_to_list(make_default_statement(context, default)),
              ),
            ],
          ),
      },
    ),
  )
}

fun make_default_statement(
  context: mutable Context,
  default: ?O.Stmt,
): JS.Pos_statement {
  default match {
  | None() -> make_throw_unmatched_branch()
  | Some(s) -> convert_stmt(context, s)
  }
}

fun convert_type_switch_branch(
  context: mutable Context,
  branch: O.TypeSwitchBranch,
): JS.Case_clause {
  JS.Case(
    branch.cases.map(pos_tid -> {
      (pos, tid) = pos_tid;
      JSU.make_int_literal(pos, get_type_switch_id(context, tid.name.id));
    }),
    JSU.statement_to_list(convert_stmt(context, branch.action)),
  )
}

fun convert_stmt_seq(
  context: mutable Context,
  stmts: List<O.Stmt>,
): List<JS.Pos_statement> {
  stmts.map(s -> convert_stmt(context, s))
}

fun convert_return_stmt(
  context: mutable Context,
  stmt: O.Stmt,
): JS.Pos_statement {
  convert_stmt(context, stmt)
}

fun convert_bind(
  context: mutable Context,
  left: O.Binding,
  init_opt: ?O.Expr,
): JS.Pos_statement {
  id = binding_to_identifier(left);
  init_opt match {
  | None() -> JSU.make_var(id)
  | Some(init) -> JSU.make_var_init(id, convert_expr(context, init))
  }
}

fun convert_try(
  context: mutable Context,
  body: O.Stmt,
  ex: O.Binding,
  sk_catch: O.Stmt,
): JS.Pos_statement {
  (
    FileRange.none,
    JS.Try(
      JS.Try_statement{
        try_block => List[convert_stmt(context, body)],
        try_catch => Some(
          (
            JSU.name_to_identifier(ex.name),
            List[convert_stmt(context, sk_catch)],
          ),
        ),
        try_finally => None(),
      },
    ),
  )
}

fun convert_named_param_initializer(
  param: ((FileRange, String), O.Parameter),
): JS.Pos_statement {
  /* let param = __named_parameters.param */
  param match {
  | ((_, id), _) ->
    name = JSU.make_predefined_name(id);
    JSU.make_var_init(
      name,
      JSU.make_dotted_name(
        JSU.make_predefined_name(JSU.__named_parameters),
        name,
      ),
    )
  }
}

fun convert_named_params(
  params: Parameters<O.Parameter>,
): List<JS.Pos_statement> {
  params match {
  | Positional _ -> List[]
  | Named(params1) ->
    params1.items().map(convert_named_param_initializer) |>
      List::createFromIterator
  }
}

fun convert_stmt_expr_as_expr(
  context: mutable Context,
  s_e: (O.Stmt, O.Expr),
): JS.Pos_expression {
  (stmt, expr) = s_e;
  paired = SkipOuterIstUtils.make_seq(stmt, O.SingleExpr(expr));
  /* (function() { return stmt; })() */
  JSU.paramless_call(
    JSU.function_of_statement(
      convert_stmt(context, SkipOuterIstUtils.set_return_default(paired)),
    ),
  )
}

/* if (param === undefined) param = param.value; */
fun convert_ensure_default_parameter(
  context: mutable Context,
  param: O.Parameter,
): JS.Pos_statement {
  local = JSU.make_identifier(param.name);
  JSU.make_if(
    JSU.make_is_undefined(local),
    JSU.make_assign_statement(
      local,
      convert_stmt_expr_as_expr(context, param.value.fromSome().asOuter()),
    ),
    None(),
  )
}

fun convert_default_params(
  context: mutable Context,
  params: Parameters<O.Parameter>,
): List<JS.Pos_statement> {
  OIU.default_parameters(params).map(p ->
    convert_ensure_default_parameter(context, p)
  )
}

// Converts a block to a generator function body.
// {
//   return sk.__.toSkipGenerator.call(this, function*() block);
// }
fun block_to_generator(block: JS.Block_statement): JS.Block_statement {
  List[
    JSU.make_return(
      JSU.make_call_call_expr(
        JSU.make_sk_private_name(JSU.make_predefined_name(JSU.toSkipGenerator)),
        List[
          JSU.make_this(FileRange.none),
          JSU.make_function_expression(FileRange.none, true, List[], block),
        ],
      ),
    ),
  ]
}

fun convert_body(
  context: mutable Context,
  body_opt: ?O.Body,
  params: Parameters<O.Parameter>,
  isGenerator: Bool,
): JS.Block_statement {
  body_opt match {
  | Some(body) ->
    block = convert_named_params(params)
      .concat(convert_default_params(context, params))
      .concat(
        JSU.statement_to_list(convert_return_stmt(context, body.asOuter())),
      );
    if (isGenerator) {
      block_to_generator(block);
    } else {
      block;
    }
  | None() -> List[JSU.make_throw_string("Unimplemented native function")]
  }
}

fun convert_parameter_name(new_id: () -> Int, name: O.Name): String {
  str = name.id;
  if (str == "_") {
    "$" + new_id()
  } else {
    JSU.name_to_identifier(name)
  }
}

/* A.4 Functions and Classes */
/* Top level functions and classes are installed on members of the 'global' object. */
/* Note that top level symbols may contain non-identifier chars, so all */
/* accesses to top level symbols use the array access syntax. */
/* Positional parameters are translated simply. */
/* Named parameters are translated as a single parameter which is an object */
/* literal named '__named_parameters' which maps names to values. */
fun convert_params(params: Parameters<O.Parameter>): Array<String> {
  params match {
  | Positional(params1) ->
    new_id = sk_create_counter();
    params1.map(param -> convert_parameter_name(new_id, param.name))
  | Named _ -> Array[JSU.__named_parameters]
  }
}

fun convert_class_params(cp_params: ?O.ClassParams): List<String> {
  cp_params match {
  | None() -> List[]
  | Some(O.ClassParams{params}) -> List::createFromItems(convert_params(params))
  }
}

fun make_default_parameter_value(
  context: mutable Context,
  param: O.Parameter,
): JS.Pos_expression {
  argumentValue = JSU.make_identifier(param.name);
  if (OIU.parameter_is_default(param)) {
    JSU.make_conditional(
      JSU.make_is_undefined(argumentValue),
      convert_stmt_expr_as_expr(context, param.value.fromSome().asOuter()),
      argumentValue,
    )
  } else {
    argumentValue
  }
}

fun convert_positional_ctor_param_initializer(
  context: mutable Context,
  param: O.Parameter,
): JS.Pos_statement {
  /* this.name = name; */
  /* this.name = (name === undefined) ? param.value : name; */
  JSU.make_assign_statement(
    JSU.make_this_access(param.name),
    make_default_parameter_value(context, param),
  )
}

/* sk.base1.prototype.__init.call(this, __named_arguments); */
fun convert_named_ctor_param_initializer(
  base_class_name: String,
): JS.Pos_statement {
  JSU.make_call_call(
    JSU.make_member_access(
      JSU.make_member_access(
        JSU.make_sk_var_name(JSU.make_predefined_name(base_class_name)),
        JSU.make_predefined_name(JSU.prototype),
      ),
      JSU.make_predefined_name(JSU.__init),
    ),
    List[
      JSU.make_this(FileRange.none),

      JSU.make_predefined_identifier(JSU.__named_parameters),
    ],
  )
}

fun base_class_names(
  all_classes: UMap<O.ClassDef>,
  sk_extends: UMap<O.Parent>,
): List<String> {
  sort_class_names_by_depth(
    sk_extends.rawKeys() |> List::createFromIterator,
    all_classes,
  )
}

fun convert_param_initializers(
  context: mutable Context,
  sk_extends: UMap<O.Parent>,
  ctor_parameters: ?O.ClassParams,
): JS.Block_statement {
  ctor_parameters match {
  | None() -> List[]
  | Some(O.ClassParams{params => Positional(params)}) ->
    List::createFromItems(
      params.map(p -> convert_positional_ctor_param_initializer(context, p)),
    )
  | Some(O.ClassParams{params => Named _}) ->
    /* TODO: consider a tail call or accumulator instead of append */
    base_class_names(context.program.class_defs, sk_extends)
      .map(ex -> convert_named_ctor_param_initializer(ex))
      .concat(
        List[
          JSU.make_call_statement(
            JSU.make_this_access(JSU.make_predefined_name(JSU.__init)),
            List[JSU.make_predefined_identifier(JSU.__named_parameters)],
          ),
        ],
      )
  }
}

fun contains_exception(sk_extends: UMap<O.Parent>): Bool {
  sk_extends.maybeGetNoPos(JSU.exception_class).isSome()
}

fun convert_constructor_body(
  context: mutable Context,
  sk_extends: UMap<O.Parent>,
  ctor_parameters: ?O.ClassParams,
): JS.Block_statement {
  convert_param_initializers(context, sk_extends, ctor_parameters);
}

/*
  Skip supports multiple inheritance, and JS methods can't be async,
  so classes with named args become:

    var sk$name;
    sk$name = sk.name = function (__named_arguments) {
      sk.base1.prototype.__init(__named_arguments);
      sk.base2.prototype.__init(__named_arguments);
      this.__init(__named_arguments);
    }

  Exceptions use prototypal inheritance. So manually set the prototype:

    sk.DerivedException.prototype = Object.create(sk.Exception.prototype);

  And call the super constructor, from the exception contructor:

      sk.Exception.call(this);

  The magic __constructor member of the prototype maps back to the 'class'.

      sk.name.prototype.__constructor = sk.name;
*/
fun convert_constructor(
  context: mutable Context,
  class_name_string: O.Name,
  sk_extends: UMap<O.Parent>,
  ctor_parameters: ?O.ClassParams,
  frozen_: JS.Pos_expression,
): List<JS.Pos_statement> {
  class_name = JSU.make_sk_var_name(class_name_string);
  pos = class_name_string.pos;
  ctor = JSU.declare_and_assign_global_declaration(
    class_name_string,
    (
      FileRange.none,
      JS.Function(
        JS.Function_definition{
          function_is_generator => false,
          function_name => JSU.name_to_identifier(class_name_string),
          function_parameters => convert_class_params(ctor_parameters),
          function_body => convert_constructor_body(
            context,
            sk_extends,
            ctor_parameters,
          ),
        },
      ),
    ),
  );
  proto = JSU.make_assign_statement(
    JSU.make_prototype(class_name),
    JSU.make_object_create(
      JSU.make_prototype(JSU.make_predefined_identifier(JSU.js_object)),
    ),
  );
  constructor = JSU.make_assign_statement(
    JSU.make_prototype_member(
      class_name,
      JSU.make_predefined_name(JSU.__constructor),
    ),
    class_name,
  );
  class_name_init = JSU.make_assign_statement(
    JSU.make_prototype_member(
      class_name,
      JSU.make_predefined_name(JSU.__classname),
    ),
    JSU.make_string_literal(pos, class_name_string.id),
  );
  frozen_init = JSU.make_assign_statement(
    JSU.make_prototype_member(
      class_name,
      JSU.make_predefined_name(JSU._frozen),
    ),
    frozen_,
  );
  type_switch_id_init = JSU.make_assign_statement(
    JSU.make_prototype_member(
      class_name,
      JSU.make_predefined_name(JSU.__type_switch_id),
    ),
    JSU.make_int_literal(
      pos,
      get_type_switch_id(context, class_name_string.id),
    ),
  );
  List[
    ctor,
    proto,
    constructor,
    class_name_init,
    frozen_init,
    type_switch_id_init,
  ]
}

/*
  sk$name.prototype.__copy = function() {
    return new sk$name(this.arg0, this.arg1, this.arg2);
  }
  sk$name.prototype.__copy = function() {
    return new sk$name(this);
  }
*/
fun convert_copy_method(
  class_name: JS.Pos_expression,
  ctor_parameters: ?O.ClassParams,
): JS.Pos_statement {
  body = ctor_parameters match {
  | None() -> List[]
  | Some(O.ClassParams{params => Positional(params)}) ->
    // return new sk$name(this.arg0, this.arg1, this.arg2);
    List[
      JSU.make_return(
        JSU.make_new_expression(
          JSU.make_paren_expression(class_name),
          List::createFromItems(params.map(p -> JSU.make_this_access(p.name))),
        ),
      ),
    ]
  | Some(O.ClassParams{params => Named _}) ->
    // return new sk$name(this);
    List[
      JSU.make_return(
        JSU.make_new_expression(
          JSU.make_paren_expression(class_name),
          List[JSU.make_this(FileRange.none)],
        ),
      ),
    ]
  };

  JSU.make_assign_statement(
    JSU.make_prototype_member(class_name, JSU.make_predefined_name(JSU.__copy)),
    (
      FileRange.none,
      JS.Function(
        JS.Function_definition{
          function_is_generator => false,
          function_name => "",
          function_parameters => List[],
          function_body => body,
        },
      ),
    ),
  )
}

/*
  sk$name.prototype.__deepFreeze = function(__cache) {
    if (this.$frozen) {
      return this;
    }
    var tmp = __cache.get(this);
    if (tmp === undefined) {
      tmp = this.__copy();
      tmp.$frozen = true;
      __cache.set(this, tmp);
      tmp.arg0 = deepFreeze(tmp.arg0, __cache);
      tmp.arg1 = deepFreeze(tmp.arg1, __cache);
    }
    return tmp;
  }
*/
fun convert_deep_freeze_method(
  context: mutable Context,
  class_name: JS.Pos_expression,
  ctor_parameters: ?O.ClassParams,
): JS.Pos_statement {
  params: List<O.Parameter> = ctor_parameters match {
  | None() -> List.Nil()
  | Some(O.ClassParams{params => Positional(params)}) ->
    List::createFromItems(params)
  | Some(O.ClassParams{params => Named(params)}) ->
    List::createFromIterator(params.values()).sortedBy((p: O.Parameter) ~> {
      p.index
    })
  };

  obj_tmp = JSU.make_predefined_name(new_tmp_sk(context.new_id));
  body = List[
    JSU.make_if(
      JSU.make_this_access(JSU.make_predefined_name(JSU._frozen)),
      JSU.make_return(JSU.make_this(FileRange.none)),
      None(),
    ),
    JSU.make_var_init(
      obj_tmp,
      JSU.make_call_expr(
        JSU.make_member_access(
          JSU.make_predefined_identifier(JSU.__cache),
          JSU.make_predefined_name(JSU.get),
        ),
        List[JSU.make_this(FileRange.none)],
      ),
    ),
    JSU.make_if(
      JSU.make_binary(
        JSU.make_identifier(obj_tmp),
        JS.BinaryStrictEquals(),
        JSU.undefined_expr(FileRange.none),
      ),
      JSU.make_block(
        List[
          List[
            JSU.make_var_init(
              obj_tmp,
              JSU.make_call_expr(
                JSU.make_member_access(
                  JSU.make_this(FileRange.none),
                  JSU.make_predefined_name(JSU.__copy),
                ),
                List[],
              ),
            ),
            JSU.make_assign_statement(
              JSU.make_member_access(
                JSU.make_identifier(obj_tmp),
                JSU.make_predefined_name(JSU._frozen),
              ),
              JSU.make_bool_literal(FileRange.none, true),
            ),
            JSU.make_call_statement(
              JSU.make_member_access(
                JSU.make_predefined_identifier(JSU.__cache),
                JSU.make_predefined_name(JSU.set),
              ),
              List[JSU.make_this(FileRange.none), JSU.make_identifier(obj_tmp)],
            ),
          ],
          params.map(param -> {
            name = param.name;
            JSU.make_assign_statement(
              JSU.make_member_access(JSU.make_identifier(obj_tmp), name),
              JSU.make_call_expr(
                JSU.make_internal_name(JSU.deepFreeze),
                List[
                  JSU.make_member_access(JSU.make_identifier(obj_tmp), name),
                  JSU.make_predefined_identifier(JSU.__cache),
                ],
              ),
            )
          }),
        ].flatten(),
      ),
      None(),
    ),
    JSU.make_return(JSU.make_identifier(obj_tmp)),
  ];

  JSU.make_assign_statement(
    JSU.make_prototype_member(
      class_name,
      JSU.make_predefined_name(JSU.__deepFreeze),
    ),
    (
      FileRange.none,
      JS.Function(
        JS.Function_definition{
          function_is_generator => false,
          function_name => "",
          function_parameters => List[JSU.__cache],
          function_body => body,
        },
      ),
    ),
  )
}

/*
    sk.name.prototype.__init = function(__named_arguments) {
      this.field = __named_arguments.field;
      this.fieldWithDefault = __named_arguments.fieldWithDefault === undefined
        ? defaultValue : __named_arguments.fieldWithDefault;
    }
*/
fun convert_init_method(
  context: mutable Context,
  class_name: JS.Pos_expression,
  ctor_parameters: ?O.ClassParams,
): JS.Pos_statement {
  convert_param_initializers = (ctor_parameters1: ?O.ClassParams) -> {
    convert_param = (param: O.Parameter) -> {
      name = param.name;
      argumentValue = JSU.make_member_access(
        JSU.make_predefined_identifier(JSU.__named_parameters),
        name,
      );
      JSU.make_assign_statement(
        JSU.make_this_access(name),
        {
          if (OIU.parameter_is_default(param)) {
            JSU.make_conditional(
              JSU.make_is_undefined(argumentValue),
              convert_stmt_expr_as_expr(
                context,
                param.value.fromSome().asOuter(),
              ),
              argumentValue,
            )
          } else {
            argumentValue
          }
        },
      )
    };
    ctor_parameters1 match {
    | None() -> List[]
    | Some(O.ClassParams{params => Positional _}) -> List[]
    | Some(O.ClassParams{params => Named(params)}) ->
      List::createFromIterator(params.values())
        .sortedBy(p ~> p.index)
        .map(convert_param)
    }
  };
  JSU.make_assign_statement(
    JSU.make_prototype_member(class_name, JSU.make_predefined_name(JSU.__init)),
    (
      FileRange.none,
      JS.Function(
        JS.Function_definition{
          function_is_generator => false,
          function_name => "",
          function_parameters => List[JSU.__named_parameters],
          function_body => convert_param_initializers(ctor_parameters),
        },
      ),
    ),
  )
}

fun convert_methods(
  context: mutable Context,
  class_name: JS.Pos_expression,
  methods: List<O.MethodDef>,
): List<JS.Pos_statement> {
  convert_method = (meth: O.MethodDef) -> {
    meth.body match {
    | None() -> invariant_violation("assert false")
    | Some(body) ->
      name = JSU.strip_position_of_name(meth.name);
      obj = if (OIU.method_is_static(meth)) {
        class_name
      } else {
        JSU.make_prototype(class_name)
      };
      is_async = meth.async_.isSome();
      is_memoized = meth.memoized_.isSome();
      rhs = JSU.maybe_memoize(
        is_memoized,
        true,
        JSU.maybe_asyncify(
          is_async,
          (
            FileRange.none,
            JS.Function(
              JS.Function_definition{
                function_is_generator => is_async,
                function_name => "",
                function_parameters => List::createFromItems(
                  convert_params(meth.params),
                ),
                function_body => convert_body(
                  context,
                  Some(body),
                  meth.params,
                  meth.yields.isSome(),
                ),
              },
            ),
          ),
        ),
      );
      /* Handle non-writable (but thankfully configurable) properties on Function values */
      if (List[JSU.length, JSU.name].contains(name.id)) {
        JSU.make_expression_statement(JSU.make_define_property(obj, name, rhs))
      } else {
        lhs = JSU.make_member_access(obj, name);
        JSU.make_assign_statement(lhs, rhs)
      }
    }
  };
  methods.filter(meth -> meth.body.isSome()).map(convert_method)
}

/*
  Class constants become 'get' properties, which are converted to values on first
  access:

     Object.defineProperty(sk.name, 'constant-name', {
      get: function() {
        var t = function() { return value; } ();
        Object.defineProperty(sk.name, 'constant-name', {
          value: t,
          writable: false,
          configurable: false,
          enumerable: true,
        });
        return t;
      },
      writable: true,
      configurable: true,
      enumerable: true,
     });
*/
fun convert_class_constant(
  context: mutable Context,
  class_name: JS.Pos_expression,
  constant: O.ConstDef,
): JS.Pos_statement {
  JSU.make_expression_statement(
    JSU.make_define_cached_get_property(
      class_name,
      constant.name,
      convert_stmt_expr_as_expr(context, constant.value.fromSome().asOuter()),
    ),
  )
}

fun convert_class_constants(
  context: mutable Context,
  class_name: JS.Pos_expression,
  constants: List<O.ConstDef>,
): List<JS.Pos_statement> {
  constants
    .filter(constant -> constant.value.isSome())
    .map(con -> convert_class_constant(context, class_name, con))
}

/* Classes */
/*
  Skip supports multiple inheritance, and JS methods can't be async,
  so classes with named args become:

    sk$name = sk.name = function name(__named_arguments) {
      sk.base1.prototype.__init(__named_arguments);
      sk.base2.prototype.__init(__named_arguments);
      this.__init(__named_arguments);
    }

    sk.name.prototype.__init(__named_arguments) {
      this.value = __named_arguments.value;
    }

  Exceptions use prototypal inheritance. So manually set the prototype:

    sk.DerivedException.prototype = Object.create(sk.Exception.prototype);

  Set the __constructor member:

    sk.name.prototype.__constructor = sk.name;

  And call the super constructor, from the exception contructor:

      sk.Exception.call(this);

  Classes with position args become:

    sk.name = function name(p1, p2) {
      this.p1 = p1;
      this.p2 = p2;
    }

  All classes have the following static initializers:

    sk.name.prototype.__bases = [sk.name, sk.base1, sk.base2];
    skip.mixinBaseMembers(sk.name, [sk.base1, sk.base2]);

  instanceof checks translate to:

    skip.isInstance(object, sk.name);

  which uses the ...prototype.__bases member to determine inheritance.

  Instance members become:

    sk.name.prototype['member-name'] = function(args) {
    }

  Static members become

    sk.name['member-name'] = function(args) {
    }

  Where both instance and static members may be asyncified if needed.

  Class constants become 'get' properties, which are converted to values on first
  access:

     Object.defineProperty(sk.name, 'constant-name', {
      get: function() {
        var t = function() { return value; } ();
        Object.defineProperty(sk.name, 'constant-name', {
          value: t,
          writable: false,
          configurable: false,
          enumerable: true,
        });
        return t;
      },
      writable: true,
      configurable: true,
      enumerable: true,
     })

 */
fun convert_class(
  context: mutable Context,
  cls: O.ClassDef,
): List<JS.Pos_statement> {
  class_name = JSU.make_sk_var_name(JSU.strip_position_of_name(cls.name));
  List[
    convert_constructor(
      context,
      JSU.strip_position_of_name(cls.name),
      cls.extends_,
      cls.params,
      if (cls.kind == O.KClass()) {
        JSU.make_bool_literal(
          FileRange.none,
          is_class_known_to_be_immutable(cls),
        )
      } else {
        JSU.undefined_expr(FileRange.none)
      },
    ),
    if (is_native_class(cls)) {
      List[]
    } else {
      List[
        convert_copy_method(class_name, cls.params),
        convert_deep_freeze_method(context, class_name, cls.params),
      ]
    },
    List[convert_init_method(context, class_name, cls.params)],
    convert_methods(
      context,
      class_name,
      cls.methods.values() |> List::createFromIterator,
    ),
  ].flatten()
}

/* TODO: This can be made more efficient. Direct base classes can be filtered out */
/* As can bases of bases */
fun create_base_list(
  all_classes: UMap<O.ClassDef>,
  cls: O.ClassDef,
): List<JS.Pos_expression> {
  base_class_names(all_classes, cls.extends_).map(s ->
    JSU.make_sk_var_name(JSU.make_predefined_name(s))
  )
}

fun create_class_name(cls: O.ClassDef): O.Name {
  cls.name
}

fun convert_global_class(
  context: mutable Context,
  cls: O.ClassDef,
): List<JS.Pos_statement> {
  class_name = (JSU.strip_position_of_name(create_class_name(cls)) : O.Name);
  base_list = (create_base_list(context.program.class_defs, cls) : List<
    JS.Pos_expression,
  >);
  /* sk[cls] = ... */
  assign_class = (convert_class(context, cls) : List<JS.Pos_statement>);
  /* sk.name.prototype.__bases = [sk.name, sk.base1, sk.base2]; */
  initialize_bases = (JSU.make_assign_statement(
    JSU.make_member_access(
      JSU.make_member_access(
        JSU.make_sk_var_name(class_name),
        JSU.make_predefined_name(JSU.prototype),
      ),
      JSU.make_predefined_name(JSU.__bases),
    ),
    JSU.make_array(List.Cons(JSU.make_sk_var_name(class_name), base_list)),
  ) : JS.Pos_statement);
  native_init = {
    if (is_native_class(cls)) {
      /* sk$name = sk.name = runtime.initNativeClass('name', sk.name); */
      sk_name = JSU.make_sk_var_name(class_name);
      str_name = JSU.make_string_literal(class_name.pos, class_name.id);
      init_cls = JSU.make_call_expr(
        JSU.make_internal_name(JSU.initNativeClass),
        List[
          JSU.make_identifier(JSU.make_predefined_name(JSU.sk)),
          str_name,
          sk_name,
        ],
      );
      List[JSU.assign_global_declaration(class_name, init_cls)]
    } else {
      List[]
    }
  };
  assign_class
    .concat(List[initialize_bases])
    .concat(native_init)
    .concat(
      convert_class_constants(
        context,
        JSU.make_sk_var_name(class_name),
        cls.consts.values() |> List::createFromIterator,
      ),
    )
}

fun convert_global_class_prototype(
  class_defs: UMap<O.ClassDef>,
  cls: O.ClassDef,
): JS.Pos_statement {
  /* skip.mixinBaseMembers(cls, [bases]) */
  sk_var = JSU.make_identifier(JSU.make_predefined_name(JSU.sk));
  JSU.make_call_statement(
    JSU.make_internal_name(JSU.mixinBaseMembers),
    List[
      sk_var,
      JSU.make_sk_var_name(create_class_name(cls)),
      JSU.make_array(create_base_list(class_defs, cls).reversed()),
    ],
  )
}

/* and we move the 'Class' class to the top for init order reasons */
/* See jslib/main.js for the full story. */
fun filter_special_order_class(classes: List<O.ClassDef>): List<O.ClassDef> {
  get_class_name = (cls: O.ClassDef) -> cls.name.id;
  not_special_order_class = cls -> get_class_name(cls) != JSU.class_class;
  classes.filter(not_special_order_class)
}

/* Base classes must be emitted before derived classes, so sort by */
/* inheritance depth */
fun depth_of_class(cls: O.ClassDef, all_classes: UMap<O.ClassDef>): Int {
  cls.extends_
    .items()
    .map(p -> 1 + depth_by_name(all_classes, p.i0.i1))
    .reduce(max, 0)
}

fun depth_by_name(all_classes: UMap<O.ClassDef>, name: String): Int {
  all_classes.maybeGetNoPos(name) match {
  | None() -> invariant_violation("assert false")
  | Some(cls) -> depth_of_class(cls, all_classes)
  }
}

fun sort_classes_by_depth(
  classes: UMap<O.ClassDef>,
  all_classes: UMap<O.ClassDef>,
): List<O.ClassDef> {
  compareDepth = cls ~> depth_of_class(cls, all_classes);
  List::createFromIterator(classes.values()).sortedBy(compareDepth)
}

fun sort_class_names_by_depth(
  classes: List<String>,
  all_classes: UMap<O.ClassDef>,
): List<String> {
  compareDepth = cls ~> depth_by_name(all_classes, cls);
  classes.sortedBy(compareDepth)
}

fun filtered_class_defs(class_defs: UMap<O.ClassDef>): List<O.ClassDef> {
  List.Cons(
    class_defs.getOrCrash(JSU.class_class),
    filter_special_order_class(sort_classes_by_depth(class_defs, class_defs)),
  )
}

fun convert_global_classes(
  context: mutable Context,
  class_defs: UMap<O.ClassDef>,
): List<JS.Pos_statement> {
  filtered_class_defs(class_defs)
    .map(cls -> convert_global_class(context, cls))
    .flatten()
}

/* Global functions */
fun convert_fun_expression(
  context: mutable Context,
  fun_def: O.FunDef,
): JS.Function_definition {
  JSU.make_function_definition(
    fun_def.async_.isSome(),
    List::createFromItems(convert_params(fun_def.params)),
    convert_body(
      context,
      fun_def.body,
      fun_def.params,
      fun_def.yields.isSome(),
    ),
  )
}

fun convert_global_fun(
  context: mutable Context,
  fun_def: O.FunDef,
): JS.Pos_statement {
  /* sk.<name> = function ... */
  is_async = fun_def.async_.isSome();
  is_memoized = fun_def.memoized_.isSome();
  JSU.declare_and_assign_global_declaration(
    fun_def.name,
    JSU.maybe_memoize(
      is_memoized,
      false,
      JSU.maybe_asyncify(
        is_async,
        (FileRange.none, JS.Function(convert_fun_expression(context, fun_def))),
      ),
    ),
  )
}

fun convert_global_funs(
  context: mutable Context,
  fun_defs: List<O.FunDef>,
): List<JS.Pos_statement> {
  fun_defs.map(fn -> convert_global_fun(context, fn))
}

/* Global constants */
fun convert_global_constant(
  context: mutable Context,
  sk_const: O.ConstDef,
): JS.Pos_statement {
  value = sk_const.value.fromSome().asOuter();
  pos = sk_const.name.pos;
  t = O.Name(pos, JSU.temp);
  /* var temp = (function() { return value; })(); */
  init = JSU.make_var_init(t, convert_stmt_expr_as_expr(context, value));
  /* return t; */
  ret = JSU.make_return(JSU.make_identifier(t));
  /* function () { return t; } */
  func = JSU.make_lambda_expression(pos, List[], List[ret]);
  /* sk$constant = sk.constant = function ... ; */
  assign = JSU.assign_global_declaration(sk_const.name, func);
  /*
    var sk$constant = sk.constant = function() {
      var t = (function() { return value; })();
      sk.constant = function () { return t; };
      return t;
    }
  */
  JSU.declare_and_assign_global_declaration(
    sk_const.name,
    JSU.make_lambda_expression(pos, List[], List[init, assign, ret]),
  )
}

fun convert_global_constants(
  context: mutable Context,
  const_defs: UMap<O.ConstDef>,
  class_defs: UMap<O.ClassDef>,
): List<JS.Pos_statement> {
  filter_natives = (const_def: O.ConstDef) -> const_def.value.isSome();
  classes = filtered_class_defs(class_defs).values().map(cls ->
    convert_global_class_prototype(class_defs, cls)
  );
  consts = const_defs.values().filter(filter_natives).map(con ->
    convert_global_constant(context, con)
  );
  classes.concat(consts) |> List::createFromIterator;
}

fun create_singleton_initializer(
  context: mutable Context,
  class_def: O.ClassDef,
): JS.Pos_statement {
  JSU.make_var_init(
    singleton_name_of_class(class_def),
    create_contructor_call(context, class_def.name, Positional(Array[])),
  )
}

fun create_singleton_classes(
  context: mutable Context,
  class_defs: UMap<O.ClassDef>,
): List<JS.Pos_statement> {
  class_defs.values().filter(OIU.class_is_singleton).map(cd ->
    create_singleton_initializer(context, cd)
  ) |> List::createFromIterator
}

fun create_header(): List<JS.Pos_statement> {
  sk_var = JSU.make_predefined_name(JSU.sk);
  sk_object = JSU.make_call_expr(JSU.make_internal_name(JSU.init), List[]);
  List[
    JSU.make_use_strict(FileRange.none),
    JSU.make_require_statement(JSU.skip, JSU.skip),
    JSU.make_var_init(sk_var, sk_object),
  ]
}

fun create_footer(global_functions: List<O.FunDef>): List<JS.Pos_statement> {
  sk_var = JSU.make_identifier(JSU.make_predefined_name(JSU.sk));
  List[
    // This assigns to the sk.name values for native functions.
    // ... but does not update the sk$name variables.
    List[
      // This assigns to the sk.name values for native functions.
      // ... but does not update the sk$name variables.
      JSU.make_call_statement(
        JSU.make_internal_name(JSU.copyNativeFunctions),
        List[sk_var],
      ),
      // Cache sk.__.makeChar in var $makeChar for faster access
      // See char.js and JSU.make_char for details.
      JSU.make_var_init(
        JSU.make_predefined_name(JSU._makeChar),
        JSU.make_sk_private_name(JSU.make_predefined_name(JSU.makeChar)),
      ),
      // Cache sk.__.void in var $void for faster access
      // See skip.js for details.
      JSU.make_var_init(
        JSU.make_predefined_name(JSU._void),
        JSU.make_sk_private_name(JSU.make_predefined_name(JSU._void)),
      ),
      // Cache singleton$None in sk.__.singleton$None for use by toSkipGenerator.
      // See skip.js for details.
      JSU.make_assign_statement(
        JSU.make_sk_private_name(JSU.singleton_name_of_class_name(JSU.None)),
        JSU.make_identifier(JSU.singleton_name_of_class_name(JSU.None)),
      ),
    ],
    global_functions.filter(OIU.function_is_native).map(fun_def ~>
      JSU.assign_global_var_declaration(
        fun_def.name,
        JSU.make_sk_name(fun_def.name),
      )
    ),
    // module.exports = sk;
    List[JSU.make_default_export(sk_var)],
  ].flatten()
}

fun compile_filter(prog: TAst.Program, filter_name: String): SkipJsIst.Script {
  prog1 = makeOuter(prog);

  context = create_context(sk_create_counter(), prog1);

  filtered_class_defs = prog1.class_defs.filter((_name, value) ->
    value.name.pos.filename == filter_name
  );
  filtered_fun_defs = prog1.fun_defs.filter((_name, value) ->
    value.name.pos.filename == filter_name
  );
  filtered_const_filter = prog1.const_defs.filter((_name, value) ->
    value.name.pos.filename == filter_name
  );
  (if (filtered_class_defs.isEmpty()) {
    List[]
  } else {
    iterator = filtered_class_defs.values().map(cls ->
      convert_global_class(context, cls)
    );
    List::createFromIterator(iterator).flatten()
  })
    .concat(
      if (filtered_fun_defs.isEmpty()) {
        List[]
      } else {
        convert_global_funs(
          context,
          filtered_fun_defs.values() |> List::createFromIterator,
        )
      },
    )
    .concat(
      if (filtered_const_filter.isEmpty()) {
        List[]
      } else {
        convert_global_constants(
          context,
          filtered_const_filter,
          prog1.class_defs,
        )
      },
    )
}

fun makeOuter(prog: TAst.Program): O.Program {
  outerProgram = SkipMakeOuterIst.program(prog);
  loweredProgram = SkipOptimizeOuterIst.program(outerProgram);
  SkipValidateOuterIst.validateProgram(loweredProgram);
  SkipRenameLocals.rename_locals(loweredProgram);
}

/* Turns out we need the class_defs to convert match expressions */
/* So we wrap the entire file in a begin/end block */
fun compile(prog: TAst.Program): SkipJsIst.Script {
  renamedLocalsProgram = makeOuter(prog);

  runCompilerPhase("Generate JS", () -> {
    context = create_context(sk_create_counter(), renamedLocalsProgram);

    List[
      create_header(),
      convert_global_classes(context, renamedLocalsProgram.class_defs),
      convert_global_funs(
        context,
        renamedLocalsProgram.fun_defs.values() |> List::createFromIterator,
      ),
      convert_global_constants(
        context,
        renamedLocalsProgram.const_defs,
        renamedLocalsProgram.class_defs,
      ),
      create_singleton_classes(context, renamedLocalsProgram.class_defs),
      create_footer(
        renamedLocalsProgram.fun_defs.values() |> List::createFromIterator,
      ),
    ].flatten()
  });
}
