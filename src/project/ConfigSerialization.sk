/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// NOTE: This file is generated by tools/generate_project_config. Do not edit it.
module SkipProjectConfig;

extension base class ProgramUnitKind {
  overridable const meta: ProgramUnitKindMetaClass = ProgramUnitKindMetaClass();
}

class ProgramUnitKindMetaClass()
  extends MetaClass<ProgramUnitKind>
  uses Serialization.Serializer<ProgramUnitKind> {
  fun description(): String {
    `ProgramUnitKind`
  }

  fun expectedType(): String {
    this.description()
  }

  fun serialize(
    _value: ProgramUnitKind,
    writer: mutable Serialization.Writer,
  ): void {
    _value match {
    | Library() -> writer.writeType("Library")
    | Program() -> writer.writeType("Program")
    }
  }

  fun deserialize(reader: mutable Serialization.Reader): ProgramUnitKind {
    childName = reader.readType();
    childName match {
    | "Library" -> Library()
    | "Program" -> Program()
    | _ -> throw Serialization.NotChildClassError("ProgramUnitKind", childName)
    }
  }
}

extension class ProgramUnitReference {
  const meta: ProgramUnitReferenceMetaClass = ProgramUnitReferenceMetaClass();
}

class ProgramUnitReferenceMetaClass()
  extends MetaClass<ProgramUnitReference>
  uses Serialization.Serializer<ProgramUnitReference> {
  fun description(): String {
    `ProgramUnitReference`
  }

  fun expectedType(): String {
    this.description()
  }

  fun serialize(
    _value: ProgramUnitReference,
    writer: mutable Serialization.Writer,
  ): void {
    record = writer.writeRecord(Array["path", "name"]);
    record.writeItem("path", _value.path, String::meta);
    record.writeItem("name", _value.name, Option::meta(String::meta));
    record.end();
  }

  fun deserialize(reader: mutable Serialization.Reader): ProgramUnitReference {
    record = reader.readRecord(Array["path", "name"]);
    tempMaybe0: ?String = None();
    temp1: ?String = None();
    loop {
      record.readKey() match {
      | Some("path") -> !tempMaybe0 = Some(record.readValue(String::meta))
      | Some("name") -> !temp1 = record.readValue(Option::meta(String::meta))
      | None() -> break void
      | Some(string) ->
        throw Serialization.FieldNotInClassError(string, Array["name", "path"])
      };
    };
    record.end();
    (tempMaybe0) match {
    | (Some(temp0)) -> ProgramUnitReference{path => temp0, name => temp1}
    | (None()) ->
      throw Serialization.RecordMissingFieldError(
        "ProgramUnitReference",
        "path",
      )
    }
  }
}

extension class Variable {
  const meta: VariableMetaClass = VariableMetaClass();
}

class VariableMetaClass()
  extends MetaClass<Variable>
  uses Serialization.Serializer<Variable> {
  fun description(): String {
    `Variable`
  }

  fun expectedType(): String {
    this.description()
  }

  fun serialize(_value: Variable, writer: mutable Serialization.Writer): void {
    record = writer.writeRecord(Array["values", "default"]);
    record.writeItem("values", _value.values, Vector::meta(String::meta));
    record.writeItem("default", _value.default, String::meta);
    record.end();
  }

  fun deserialize(reader: mutable Serialization.Reader): Variable {
    record = reader.readRecord(Array["values", "default"]);
    temp0: Vector<String> = Vector[];
    tempMaybe1: ?String = None();
    loop {
      record.readKey() match {
      | Some("values") -> !temp0 = record.readValue(Vector::meta(String::meta))
      | Some("default") -> !tempMaybe1 = Some(record.readValue(String::meta))
      | None() -> break void
      | Some(string) ->
        throw Serialization.FieldNotInClassError(
          string,
          Array["default", "values"],
        )
      };
    };
    record.end();
    (tempMaybe1) match {
    | (Some(temp1)) -> Variable{values => temp0, default => temp1}
    | (None()) ->
      throw Serialization.RecordMissingFieldError("Variable", "values")
    }
  }
}

extension class ParameterValue {
  const meta: ParameterValueMetaClass = ParameterValueMetaClass();
}

class ParameterValueMetaClass()
  extends MetaClass<ParameterValue>
  uses Serialization.Serializer<ParameterValue> {
  fun description(): String {
    `ParameterValue`
  }

  fun expectedType(): String {
    this.description()
  }

  fun serialize(
    _value: ParameterValue,
    writer: mutable Serialization.Writer,
  ): void {
    record = writer.writeRecord(Array["sources", "excludes"]);
    record.writeItem("sources", _value.sources, Vector::meta(String::meta));
    record.writeItem("excludes", _value.excludes, Vector::meta(String::meta));
    record.end();
  }

  fun deserialize(reader: mutable Serialization.Reader): ParameterValue {
    record = reader.readRecord(Array["sources", "excludes"]);
    temp0: Vector<String> = Vector[];
    temp1: Vector<String> = Vector[];
    loop {
      record.readKey() match {
      | Some("sources") -> !temp0 = record.readValue(Vector::meta(String::meta))
      | Some("excludes") ->
        !temp1 = record.readValue(Vector::meta(String::meta))
      | None() -> break void
      | Some(string) ->
        throw Serialization.FieldNotInClassError(
          string,
          Array["excludes", "sources"],
        )
      };
    };
    record.end();
    ParameterValue{sources => temp0, excludes => temp1}
  }
}

extension class ProgramUnit {
  const meta: ProgramUnitMetaClass = ProgramUnitMetaClass();
}

class ProgramUnitMetaClass()
  extends MetaClass<ProgramUnit>
  uses Serialization.Serializer<ProgramUnit> {
  fun description(): String {
    `ProgramUnit`
  }

  fun expectedType(): String {
    this.description()
  }

  fun serialize(
    _value: ProgramUnit,
    writer: mutable Serialization.Writer,
  ): void {
    record = writer.writeRecord(
      Array["sources", "excludes", "kind", "references", "parameters"],
    );
    record.writeItem("sources", _value.sources, Vector::meta(String::meta));
    record.writeItem("excludes", _value.excludes, Vector::meta(String::meta));
    record.writeItem("kind", _value.kind, ProgramUnitKind::meta);
    record.writeItem(
      "references",
      _value.references,
      Vector::meta(ProgramUnitReference::meta),
    );
    record.writeItem(
      "parameters",
      _value.parameters,
      Map::meta(String::meta, Map::meta(String::meta, ParameterValue::meta)),
    );
    record.end();
  }

  fun deserialize(reader: mutable Serialization.Reader): ProgramUnit {
    record = reader.readRecord(
      Array["sources", "excludes", "kind", "references", "parameters"],
    );
    temp0: Vector<String> = Vector[];
    temp1: Vector<String> = Vector[];
    tempMaybe2: ?ProgramUnitKind = None();
    temp3: Vector<ProgramUnitReference> = Vector[];
    temp4: Map<String, Map<String, ParameterValue>> = Map[];
    loop {
      record.readKey() match {
      | Some("sources") -> !temp0 = record.readValue(Vector::meta(String::meta))
      | Some("excludes") ->
        !temp1 = record.readValue(Vector::meta(String::meta))
      | Some("kind") ->
        !tempMaybe2 = Some(record.readValue(ProgramUnitKind::meta))
      | Some("references") ->
        !temp3 = record.readValue(Vector::meta(ProgramUnitReference::meta))
      | Some("parameters") ->
        !temp4 = record.readValue(
          Map::meta(
            String::meta,
            Map::meta(String::meta, ParameterValue::meta),
          ),
        )
      | None() -> break void
      | Some(string) ->
        throw Serialization.FieldNotInClassError(
          string,
          Array["excludes", "kind", "parameters", "references", "sources"],
        )
      };
    };
    record.end();
    (tempMaybe2) match {
    | (Some(temp2)) ->
      ProgramUnit{
        sources => temp0,
        excludes => temp1,
        kind => temp2,
        references => temp3,
        parameters => temp4,
      }
    | (None()) ->
      throw Serialization.RecordMissingFieldError("ProgramUnit", "sources")
    }
  }
}

extension class Project {
  const meta: ProjectMetaClass = ProjectMetaClass();
}

class ProjectMetaClass()
  extends MetaClass<Project>
  uses Serialization.Serializer<Project> {
  fun description(): String {
    `Project`
  }

  fun expectedType(): String {
    this.description()
  }

  fun serialize(_value: Project, writer: mutable Serialization.Writer): void {
    record = writer.writeRecord(
      Array["skipVersion", "programUnits", "default", "variables"],
    );
    record.writeItem("skipVersion", _value.skipVersion, String::meta);
    record.writeItem(
      "programUnits",
      _value.programUnits,
      Map::meta(String::meta, ProgramUnit::meta),
    );
    record.writeItem("default", _value.default, Option::meta(String::meta));
    record.writeItem(
      "variables",
      _value.variables,
      Map::meta(String::meta, Variable::meta),
    );
    record.end();
  }

  fun deserialize(reader: mutable Serialization.Reader): Project {
    record = reader.readRecord(
      Array["skipVersion", "programUnits", "default", "variables"],
    );
    tempMaybe0: ?String = None();
    temp1: Map<String, ProgramUnit> = Map[];
    temp2: ?String = None();
    temp3: Map<String, Variable> = Map[];
    loop {
      record.readKey() match {
      | Some("skipVersion") ->
        !tempMaybe0 = Some(record.readValue(String::meta))
      | Some("programUnits") ->
        !temp1 = record.readValue(Map::meta(String::meta, ProgramUnit::meta))
      | Some("default") -> !temp2 = record.readValue(Option::meta(String::meta))
      | Some("variables") ->
        !temp3 = record.readValue(Map::meta(String::meta, Variable::meta))
      | None() -> break void
      | Some(string) ->
        throw Serialization.FieldNotInClassError(
          string,
          Array["default", "programUnits", "skipVersion", "variables"],
        )
      };
    };
    record.end();
    (tempMaybe0) match {
    | (Some(temp0)) ->
      Project{
        skipVersion => temp0,
        programUnits => temp1,
        default => temp2,
        variables => temp3,
      }
    | (None()) ->
      throw Serialization.RecordMissingFieldError("Project", "skipVersion")
    }
  }
}
module end;
